title: windows pe 权威指南
date: 2015-06-08 22:58:58
categories:
  - 逆向工程
---

![](http://img4.douban.com/lpic/s6950799.jpg)

格式：EPUB
类型：文字版

<!--more-->

## 出版信息 ##

作者: 戚利 
出版社: 机械工业出版社华章公司
副标题: 剖析Windows PE文件格式的原理及编程技术
出版年: 2011-10
页数: 672
定价: 89.00元
ISBN: 9787111354185

## 简介 ##

内容全面，详尽地剖析了Windows PE文件格式的原理及其编程技术，涉及安全领域的各个方面和Windows系统的进程管理和底层机制；实战性强，以案例驱动的方式讲解了Windows PE文件格式在加密与解密、软件汉化、逆向工程、反病毒等安全领域的应用，不仅每个知识点都配有小案例，而且还有多个完整的商业案例。
全书共分为三大部分：第一部分简单介绍了学习本书需要搭建的工作环境和必须具备的工具，深入分析了PE文件头、导入表、导出表、重定位表、资源表、延迟导入表、线程局部存储、加载配置信息等核心技术的概念、原理及其编程方法，针对性地讲解了程序设计中的重定位、程序堆栈、动态加载等；第二部分讨论了PE头部的变形技术及静态附加补丁的技术，其中静态附加补丁技术重点讲解了如何在空闲空间、间隙、新节、最后一节等四种情况下打补丁和进行编码的方法；第三部分精心编写了多个大型而完整的PE应用案例，以PE补丁作为重要手段，通过对目标PE文件实施不同的补丁内容来实现不同的应用，详细展示了EXE捆绑器、软件安装自动化、EXE加锁器、EXE加密、PE病毒提示器以及PE病毒的实现过程和方法。
本书不仅适合想深入理解Windows系统进程管理和运作机制的读者，而且还适合从事加密与解密、软件汉化、逆向工程、反病毒工作的安全工作者。此外，它还适合想全面了解Windows PE文件结构和对程序字节码感兴趣的读者。

## 目录 ##

前言
第一部分　PE的原理和基础
第1章　Windows PE 开发环境/2
1.1　开发语言MASM32 /2
1.1.1　设置开发环境/3
1.1.2　开发第一个源程序HelloWorld.asm /5
1.1.3　运行HelloWorld.exe /7
1.2　调试软件OllyDBG /10
1.2.1　调试HelloWorld.exe /10
1.2.2　修改EXE文件字节码 /16
1.3　十六进制编辑软件FlexHex /18
1.4　破解实例：U盘监控器 /20
1.5　初识PE文件 /23
1.6　小结 /26
第2章　三个小工具的编写/27
2.1　构造基本窗口程序/27
2.1.1　构造窗口界面/27
2.1.2　编写相关的资源文件/28
2.1.3　通用程序框架的实现/29
2.2　PEDump的实现/32
2.2.1　编程思路/32
2.2.2　PEDump编码/34
2.2.3　PEDump代码中的数据结构/38
2.2.4　运行PEDump /39
2.3　PEComp的实现/40
2.3.1　编程思路/41
2.3.2　定义资源文件/41
2.3.3　PEComp编码/41
2.3.4　运行PEComp /47
2.4　PEInfo的实现/47
2.4.1　编程思路/48
2.4.2　PEInfo编码/48
2.4.3　运行PEInfo /52
2.5　小结/53
第3章　PE文件头/54
3.1　PE的数据组织方式/54
3.2　与PE有关的基本概念/58
3.2.1　地址/58
3.2.2　指针/60
3.2.3　数据目录/60
3.2.4　节/60
3.2.5　对齐/61
3.2.6　Unicode字符串/62
3.3　PE文件结构/62
3.3.1　16位系统下的PE结构/62
3.3.2　32位系统下的PE结构/66
3.3.3　程序员眼中的PE结构/68
3.4　PE文件头部解析/69
3.4.1　DOS MZ头IMAGE_DOS_HEADER /69
3.4.2　PE头标识Signature /69
3.4.3　标准PE头IMAGE_FILE_HEADER /70
3.4.4　扩展PE头IMAGE_OPTIONAL_HEADER32 /70
3.4.5　PE头IMAGE_NT_HEADERS /71
3.4.6　数据目录项IMAGE_DATA_DIRECTORY /71
3.4.7　节表项IMAGE_SECTION_HEADER /74
3.5　数据结构字段详解/74
3.5.1　PE头IMAGE_NT_HEADER的字段/75
3.5.2　标准PE头IAMGE_FILE_HEADER的字段/75
3.5.3　扩展PE头IMAGE_OPTIONAL_HEADER32的字段/78
3.5.4　数据目录项IMAGE_DATA_DIRECTORY的字段/87
3.5.5　节表项IMAGE_SECTION_HEADER的字段/87
3.5.6　解析HelloWorld程序的字节码/88
3.6　PE内存映像/92
3.7　PE文件头编程/93
3.7.1　RVA与FOA的转换/93
3.7.2　数据定位/95
3.7.3　标志位操作/101
3.7.4　PE校验和/102
3.8　小结/104
第4章　导入表/105
4.1　何谓导入表/105
4.2　导入函数/105
4.2.1　invoke指令分解/106
4.2.2　导入函数地址/107
4.2.3　导入函数宿主/109
4.3　PE中的导入表/112
4.3.1　导入表定位/112
4.3.2　导入表描述符IMAGE_IMPORT_DESCRIPTOR /113
4.3.3　导入表的双桥结构/114
4.3.4　导入函数地址表/116
4.3.5　构造调用同一个DLL文件的多个函数的导入表/117
4.4　导入表编程/121
4.4.1　导入表遍历的思路/121
4.4.2　编写函数_getImportInfo /122
4.4.3　运行测试/124
4.5　绑定导入/124
4.5.1　绑定导入机制/124
4.5.2　绑定导入数据定位/125
4.5.3　绑定导入数据结构/126
4.5.4　绑定导入实例分析/127
4.6　手工重组导入表/128
4.6.1　常用注册表API /128
4.6.2　构造目标指令/132
4.6.3　PE头部变化/135
4.6.4　手工重组/136
4.6.5　程序实现/141
4.6.6　思考：关于IAT的连贯性/142
4.6.7　思考：关于导入表的位置/143
4.7　小结/144
第5章　导出表/145
5.1　导出表的作用/145
5.1.1　分析动态链接库功能/145
5.1.2　获得导出函数地址/146
5.2　构造含导出表的PE文件/146
5.2.1　DLL源代码/147
5.2.2　编写def文件/151
5.2.3　编译和链接/152
5.2.4　编写头文件/152
5.2.5　使用导出函数/152
5.3　导出表数据结构/155
5.3.1　导出表定位/155
5.3.2　导出目录IMAGE_EXPORT_DIRECTORY/156
5.3.3　导出表实例分析/158
5.4　导出表编程/160
5.4.1　根据编号查找函数地址/160
5.4.2　根据名字查找函数地址/160
5.4.3　遍历导出表/162
5.5　导出表的应用/165
5.5.1　导出函数覆盖/165
5.5.2　导出私有函数/167
5.6　小结/169
第6 章　栈与重定位表/170
6.1　栈/170
6.1.1　栈的应用场合/170
6.1.2　call调用中的栈实例分析/173
6.1.3　栈溢出/177
6.2　代码重定位/181
6.2.1　重定位的提出 /181
6.2.2　实现重定位的方法/182
6.2.3　重定位编程/183
6.3　PE文件头中的重定位表/189
6.3.1　重定位表定位/189
6.3.2　重定位表项IMAGE_BASE_RELOCATION /190
6.3.3　重定位表的结构/191
6.3.4　遍历重定位表/192
6.3.5　重定位表实例分析/195
6.4　小结/196
第7章　资源表/197
7.1　资源分类/197
7.1.1　位图、光标、图标资源/199
7.1.2　菜单资源/199
7.1.3　对话框资源/200
7.1.4　自定义资源/201
7.2　PE资源表组织/202
7.2.1　资源表的组织方式/202
7.2.2　资源表数据定位/203
7.2.3　资源目录头IMAGE_RESOURCE_DIRECTORY /204
7.2.4　资源目录项IMAGE_RESOURCE_DIRECTORY_ENTRY /205
7.2.5　资源数据项IMAGE_RESOURCE_DATA_ENTRY /206
7.2.6　三级结构中目录项的区别/207
7.3　资源表遍历/208
7.4　PE资源深度解析/213
7.4.1　资源脚本/213
7.4.2　使用PEInfo分析资源表/214
7.4.3　菜单资源解析/216
7.4.4　图标资源解析/218
7.4.5　图标组资源解析/223
7.4.6　对话框资源解析/224
7.5　资源表编程/228
7.5.1　更改图标实验/229
7.5.2　提取程序图标实例/231
7.5.3　更改程序图标实例/241
7.6　小结/244
第8章　延迟加载导入表/245
8.1　延迟加载导入的概念及其作用/245
8.1.1　提高应用程序加载速度/246
8.1.2　提高应用程序兼容性/246
8.1.3　提高应用程序可整合性/247
8.2　PE中的延迟加载导入表/247
8.2.1　延迟加载导入表数据定位/247
8.2.2　延迟加载导入描述符IMAGE_DELAY_IMPORT_DESCRIPTOR /248
8.2.3　延迟加载导入表实例分析/249
8.3　延迟加载导入机制详解/251
8.4　延迟加载导入编程/253
8.4.1　修改资源文件pe.rc /253
8.4.2　修改源代码pe.asm /253
8.5　关于延迟加载导入的两个问题/255
8.5.1　异常处理/255
8.5.2　 DLL的卸载/255
8.6　小结/256
第9章　线程局部存储/257
9.1　Windows进程与线程/257
9.1.1　Windows体系结构/257
9.1.2　进程与线程创建/258
9.1.3　进程环境块PEB /262
9.1.4　线程环境块TEB /264
9.2　什么是线程局部存储/265
9.3　动态线程局部存储/267
9.3.1　动态TLS实例/267
9.3.2　获取索引TlsAlloc /274
9.3.3　按索引取值TlsGetValue /275
9.3.4　按索引存储TlsSetValue /275
9.3.5　释放索引TlsFree /275
9.4　静态线程局部存储/276
9.4.1　TLS定位/277
9.4.2　TLS目录结构IMAGE_TLS_DIRECTORY32 /278
9.4.3　静态TLS实例分析/278
9.4.4　TLS回调函数/279
9.4.5　测试静态TLS下的线程存储初始化回调函数/280
9.5　小结/281
第10章　加载配置信息/282
10.1　何谓加载配置信息/282
10.2　Windows结构化异常处理/282
10.2.1　什么是SEH /283
10.2.2　Windows异常分类/285
10.2.3　内核模式下的异常处理/286
10.2.4　用户模式下的异常处理/289
10.2.5　Windows SEH机制解析/294
10.2.6　SEH编程实例/295
10.3　PE中的加载配置信息/299
10.3.1　加载配置信息定位/300
10.3.2　加载配置目录IMAGE_LOAD_CONFIG_DIRECTORY /300
10.3.3　加载配置信息实例分析/302
10.4　加载配置编程/303
10.4.1　程序源代码分析/304
10.4.2　为PE添加加载配置信息/306
10.4.3　运行测试/306
10.4.4　注册多个异常处理函数示例/307
10.5　小结/309
第11章　动态加载技术/310
11.1　Windows虚拟地址空间分配/310
11.1.1　用户态低2GB空间分配/310
11.1.2　核心态高2GB空间分配/311
11.1.3　HelloWorld进程空间分析/312
11.2　Windows动态库技术/313
11.2.1　 DLL静态调用/313
11.2.2　 DLL动态调用/314
11.2.3　导出函数起始地址实例/314
11.3　在编程中使用动态加载技术/315
11.3.1　获取kernel32.dll基地址/316
11.3.2　获取GetProcAddress地址/322
11.3.3　在代码中使用获取的函数地址编程/325
11.3.4　动态API技术编程实例/327
11.4　小结/330
第二部分　PE进阶
第12章　PE变形技术/332
12.1　变形技术的分类/332
12.1.1　结构重叠技术/332
12.1.2　空间调整技术/333
12.1.3　数据转移技术/334
12.1.4　数据压缩技术/338
12.2　变形技术可用的空间/341
12.2.1　文件头部未用的字段/341
12.2.2　大小不固定的数据块/343
12.2.3　因对齐产生的补足空间/344
12.3　PE文件变形原则/344
12.3.1　关于数据目录表/344
12.3.2　关于节表/344
12.3.3　关于导入表/344
12.3.4　关于程序数据/345
12.3.5　关于对齐/345
12.3.6　几个关注的字段/345
12.4　将PE变小的实例HelloWorldPE /346
12.4.1　源程序HelloWorld的字节码（2560字节） /346
12.4.2　目标PE文件的字节码（432字节）/348
12.5　打造目标PE的步骤/349
12.5.1　对文件头的处理/349
12.5.2　对代码段的处理/350
12.5.3　对导入表的处理/351
12.5.4　对部分字段值的修正/351
12.5.5　修改后的文件结构/352
12.5.6　修改后的文件分析/353
12.5.7　目标文件更小的实例分析/354
12.6　小结/359
第13章　PE补丁技术/360
13.1　动态补丁/360
13.1.1　进程间的通信机制/360
13.1.2　读写进程内存/363
13.1.3　目标进程枚举/368
13.1.4　执行远程线程/373
13.2　静态补丁/379
13.2.1　整体替换PE文件/379
13.2.2　整体替换DLL文件/385
13.2.3　部分修改PE文件/387
13.3　嵌入补丁程序/388
13.3.1　嵌入补丁程序框架/388
13.3.2　嵌入补丁程序编写规则/394
13.3.3　嵌入补丁字节码实例分析/395
13.4　万能补丁码/396
13.4.1　原理/396
13.4.2　源代码/397
13.4.3　字节码/399
13.4.4　运行测试/399
13.5　小结/399
第14章　在PE空闲空间中插入程序/400
14.1　什么是 PE空闲空间/400
14.1.1　PE文件中的可用空间/400
14.1.2　获取PE文件可用空间的代码/400
14.1.3　获取PE文件可用空间的测试/403
14.2　添加注册表启动项的补丁程序实例 /403
14.2.1　补丁程序的源代码/403
14.2.2　补丁程序的字节码/404
14.2.3　目标PE的字节码/405
14.3　手工打造目标PE的步骤/408
14.3.1　基本思路/408
14.3.2　对代码段的处理/408
14.3.3　对导入表的处理/413
14.3.4　对数据段的处理/418
14.3.5　修改前后PE文件对比/421
14.4　开发补丁工具/422
14.4.1　编程思路/422
14.4.2　数据结构分析/423
14.4.3　运行测试/427
14.4.4　适应性测试实例分析/430
14.5　小结/434
第15章　在PE间隙中插入程序/435
15.1　什么是PE间隙/435
15.1.1　构造间隙一/436
15.1.2　间隙一与参数/436
15.2　插入HelloWorld的补丁程序实例/437
15.2.1　补丁程序字节码/437
15.2.2　目标PE结构/439
15.3　开发补丁工具/439
15.3.1　编程思路/439
15.3.2　数据结构分析/440
15.3.3　主要代码/442
15.3.4　运行测试/447
15.4　存在绑定导入数据的PE补丁程序实例 /448
15.4.1　改进补丁程序/448
15.4.2　修正补丁工具/450
15.4.3　为记事本程序打补丁/456
15.5　小结/457
第16章　在PE新增节中插入程序/458
16.1　新增PE节的方法/458
16.2　在本地建立子目录的补丁程序实例	/458
16.2.1　补丁程序源代码/459
16.2.2　目标PE结构 /464
16.3　开发补丁工具 /465
16.3.1　编程思路/465
16.3.2　为变量赋值/466
16.3.3　构造新文件数据/466
16.3.4　修正字段参数/466
16.3.5　主要代码/467
16.3.6　运行测试/475
16.4　小结/475
第17章　在PE最后一节中插入程序/476
17.1　网络文件下载器补丁程序实例/476
17.1.1　用到的API函数/476
17.1.2　补丁功能的预演代码/482
17.1.3　补丁程序的源代码/484
17.1.4　目标PE结构/485
17.2　开发补丁工具/486
17.2.1　编程思路/486
17.2.2　主要代码/487
17.2.3　运行测试/490
17.3　小结/491
第三部分　PE的应用案例
第18章　EXE捆绑器/494
18.1　基本思路 /494
18.2　EXE执行调度机制	/495
18.2.1　相关API函数/495
18.2.2　控制进程同步运行实例分析/499
18.3　字节码转换工具hex2db /500
18.3.1　hex2db源代码/500
18.3.2　运行测试/507
18.4　执行调度程序_host.exe /508
18.4.1　主要代码/508
18.4.2　数据结构分析/510
18.5　宿主程序host.exe /511
18.5.1　宿主程序的功能/511
18.5.2　宿主程序的状态/511
18.5.3　遍历文件/512
18.5.4　释放文件/514
18.5.5　宿主程序主函数/517
18.6　EXE捆绑器bind.exe /517
18.6.1　绑定列表定位/517
18.6.2　捆绑步骤及主要代码/518
18.6.3　测试运行/523
18.7　小结/524
第19章　软件安装自动化/525
19.1　基本思路/525
19.2　补丁程序patch.exe /525
19.2.1　相关API函数/526
19.2.2　执行线程函数/526
19.2.3　简单测试/528
19.3　消息发送器_Message.exe /529
19.3.1　窗口枚举回调函数/529
19.3.2　调用窗口枚举函数/530
19.3.3　向指定窗口发送消息/531
19.3.4　消息发送器源代码/532
19.3.5　测试运行/535
19.4　消息发送器生成工厂MessageFactory.exe /535
19.4.1　消息发送函数/535
19.4.2　键盘虚拟码/537
19.4.3　改进的消息发送器实例分析/540
19.4.4　消息发送器生成工厂代码结构/542
19.4.5　代码与数据的定位/544
19.4.6　提取代码字节码/545
19.5　软件安装自动化主程序AutoSetup.exe /548
19.5.1　主要代码/548
19.5.2　测试运行/552
19.6　小结/554
第20章　EXE加锁器/555
20.1　基本思路/555
20.2　免资源文件的窗口程序nores.asm /556
20.2.1　窗口创建函数CreateWindowEx /556
20.2.2　创建用户登录窗口的控件/558
20.2.3　窗口程序源代码 /558
20.3　免重定位的窗口程序login.asm /562
20.4　补丁程序patch.asm	/570
20.4.1　获取导入库及函数/570
20.4.2　按照补丁框架修改login.asm /571
20.4.3　补丁程序主要代码/572
20.5　附加补丁运行/573
20.6　小结/575
第21章　 EXE加密/576
21.1　基本思路/576
21.2　加密算法/577
21.2.1　加密算法的分类/577
21.2.2　自定义可逆加密算法实例/578
21.2.3　构造加密基表/579
21.2.4　利用基表测试加密数据/581
21.3　开发补丁工具/582
21.3.1　转移数据目录/582
21.3.2　传递程序参数/585
21.3.3　加密节区内容/587
21.4　处理补丁程序/588
21.4.1　还原数据目录表/588
21.4.2　解密节区内容/590
21.4.3　加载目标DLL /592
21.4.4　修正目标IAT /594
21.5　小结/595
第22章　PE病毒提示器/596
22.1　基本思路 /596
22.1.1　志愿者的选择条件/596
22.1.2　判断病毒感染的原理/597
22.2　手工打造PE病毒提示器 /597
22.2.1　编程思路 /597
22.2.2　分析目标文件的导入表 /598
22.2.3　补丁程序的源代码/601
22.2.4　补丁程序的字节码/608
22.2.5　修正函数地址/609
22.2.6　测试运行/610
22.3　补丁版的PE病毒提示器/611
22.3.1　将提示器写入启动项/611
22.3.2　检测特定位置校验和/612
22.3.3　测试运行/615
22.4　小结/617
第23章　破解PE病毒/618
23.1　病毒保护技术/618
23.1.1　花指令/619
23.1.2　反跟踪技术/620
23.1.3　反调试技术/621
23.1.4　自修改技术/624
23.1.5　注册表项保护技术/625
23.1.6　进程保护技术/627
23.2　PE病毒补丁程序解析/632
23.2.1　病毒特征/633
23.2.2　补丁程序的源代码分析/633
23.2.3　病毒传播测试/648
23.2.4　感染前后PE结构对比/650
23.3　解毒代码的编写/650
23.3.1　基本思路/651
23.3.2　计算病毒代码大小/651
23.3.3　获取原始入口地址/652
23.3.4　修正PE头部的其他参数/652
23.3.5　主要代码/653
23.3.6　运行测试 /656
23.4　小结/657
后记/658

## 下载 ##

+ [百度云下载](http://pan.baidu.com/s/1bnmG32R)
+ [微盘下载](http://vdisk.weibo.com/s/aADaW4YRFtpQ6)
+ [MEGA下载](https://mega.co.nz/#!mVFxXTDA!0HhRwCBiFbc-EajeQO0rJiG2s1Y6POkcwJusH5-G4fg)
+ [千易下载](http://1000eb.com/1ggcv)
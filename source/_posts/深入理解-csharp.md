title: 深入理解c#（中文第三版）
date: 2015-05-23 15:42:10
categories:
  - csharp
---

![](http://img3.douban.com/lpic/s27344183.jpg)

格式：PDF
类型：扫描版
大小：16.7M

<!--more-->

## 出版信息 ##

作者: 斯基特 (Jon Skeet) 
出版社: 人民邮电出版社
原作名: C# in depth
译者: 姚琪琳 
出版年: 2014-4-1
页数: 490
定价: CNY 99.00
装帧: 平装
ISBN: 9787115346421

## 简介 ##

本书是世界顶级技术专家“十年磨一剑”的经典之作，在C#和.NET领域享有盛誉。与其他泛泛介绍C#的书籍不同，本书深度探究C#的特性，并结合技术发展，引领读者深入C#的时空。作者从语言设计的动机出发，介绍支持这些特性的核心概念。作者将新的语言特性放在C#语言发展的背景之上，用极富实际意义的示例，向读者展示编写代码和设计解决方案的最佳方式。同时作者将多年的C#开发经验与读者分享，读者可咀其精华、免走弯路，使程序设计水平更上一层楼。
本书在第2版的基础上全面调整了C#语言的细节，改写了随着技术的发展已经不再适用的内容，并全面介绍了C# 5新增的大特性——异步，以及两个小特性，延续了读者期望的高标准。

## 目录 ##

第一部分　基础知识
第1章　C#开发的进化史　　2
1.1 　从简单的数据类型开始　　3
1.1.1 　C# 1中定义的产品类型　　3
1.1.2 　C# 2中的强类型集合　　4
1.1.3 　C# 3中自动实现的属性　　5
1.1.4 　C# 4中的命名实参　　6
1.2 　排序和过滤　　7
1.2.1 　按名称对产品进行排序　　7
1.2.2 　查询集合　　10
1.3 　处理未知数据　　12
1.3.1 　表示未知的价格　　12
1.3.2 　可选参数和默认值　　13
1.4 　LINQ简介　　14
1.4.1 　查询表达式和进程内查询　　14
1.4.2 　查询XML　　15
1.4.3 　LINQ to SQL　　16
1.5 　COM和动态类型　　17
1.5.1 　简化COM互操作　　17
1.5.2 　与动态语言互操作　　18
1.6 　轻松编写异步代码　　19
1.7 　剖析.NET平台　　20
1.7.1 　C#语言　　20
1.7.2 　运行时　　21
1.7.3 　框架库　　21
1.8 　怎样写出超炫的代码　　22
1.8.1 　采用代码段形式的全能代码　　22
1.8.2 　教学代码不是产品代码　　23
1.8.3 　你的新朋友：语言规范　　23
1.9 　小结　　24
第2章　C# 1所搭建的核心基础　　25
2.1 　委托　　25
2.1.1 　简单委托的构成　　26
2.1.2 　合并和删除委托　　30
2.1.3 　对事件的简单讨论　　32
2.1.4 　委托总结　　33
2.2 　类型系统的特征　　33
2.2.1 　C#在类型系统世界中的位置　　34
2.2.2 　C# 1的类型系统何时不够用　　36
2.2.3 　类型系统特征总结　　39
2.3 　值类型和引用类型　　39
2.3.1 　现实世界中的值和引用　　39
2.3.2 　值类型和引用类型基础知识　　40
2.3.3 　走出误区　　41
2.3.4 　装箱和拆箱　　43
2.3.5 　值类型和引用类型小结　　44
2.4 　C# 1之外：构建于坚实基础之上的新
特性　　44
2.4.1 　与委托有关的特性　　44
2.4.2 　与类型系统有关的特性　　46
2.4.3 　与值类型有关的特性　　48
2.5 　小结　　49
第二部分　C# 2 ：解决C# 1 的问题
第3章　用泛型实现参数化类型　　52
3.1 　为什么需要泛型　　53
3.2 　日常使用的简单泛型　　54
3.2.1 　通过例子来学习：泛型字典　　54
3.2.2 　泛型类型和类型参数　　56
3.2.3 　泛型方法和判读泛型声明　　59
3.3 　深化与提高　　62
3.3.1 　类型约束　　62
3.3.2 　泛型方法类型实参的类型推断　　67
3.3.3 　实现泛型　　68
3.4 　高级泛型　　73
3.4.1 　静态字段和静态构造函数　　73
3.4.2 　JIT编译器如何处理泛型　　75
3.4.3 　泛型迭代　　77
3.4.4 　反射和泛型　　79
3.5 　泛型在C#和其他语言中的限制　　82
3.5.1 　泛型可变性的缺乏　　83
3.5.2 　缺乏操作符约束或者“数值”约束　　87
3.5.3 　缺乏泛型属性、索引器和其他成员类型　　88
3.5.4 　同C++模板的对比　　89
3.5.5 　和Java泛型的对比　　90
3.6 　小结　　91
第4章　可空类型　　93
4.1 　没有值时怎么办　　93
4.1.1 　为什么值类型的变量不能是
null　　94
4.1.2 　在C# 1中表示空值的模式　　94
4.2 　System.Nullable<T>和System.
Nullable　　96
4.2.1 　Nullable<T>简介　　96
4.2.2 　Nullable<T>装箱和拆箱　　99
4.2.3 　Nullable<T>实例的相等性　　100
4.2.4 　来自非泛型Nullable类的
支持　　101
4.3 　C# 2为可空类型提供的语法糖　　101
4.3.1 　?修饰符　　102
4.3.2 　使用null进行赋值和比较　　103
4.3.3 　可空转换和操作符　　105
4.3.4 　可空逻辑　　108
4.3.5 　对可空类型使用as操作符　　109
4.3.6 　空合并操作符　　110
4.4 　可空类型的新奇用法　　112
4.4.1 　尝试一个不使用输出参数的
操作　　113
4.4.2 　空合并操作符让比较不再痛苦　　115
4.5 　小结　　117
第5章　进入快速通道的委托　　118
5.1 　向笨拙的委托语法说拜拜　　119
5.2 　方法组转换　　120
5.3 　协变性和逆变性　　122
5.3.1 　委托参数的逆变性　　122
5.3.2 　委托返回类型的协变性　　123
5.3.3 　不兼容的风险　　124
5.4 　使用匿名方法的内联委托操作　　125
5.4.1 　从简单的开始：处理一个参数　　126
5.4.2 　匿名方法的返回值　　128
5.4.3 　忽略委托参数　　129
5.5 　匿名方法中的捕获变量　　131
5.5.1 　定义闭包和不同类型的变量　　131
5.5.2 　捕获变量的行为　　132
5.5.3 　捕获变量到底有什么用处　　133
5.5.4 　捕获变量的延长生存期　　134
5.5.5 　局部变量实例化　　135
5.5.6 　共享和非共享的变量混合使用　　137
5.5.7 　捕获变量的使用规则和小结　　139
5.6 　小结　　140
第6章　实现迭代器的捷径　　141
6.1 　C# 1：手写迭代器的痛苦　　142
6.2 　C# 2：利用yield语句简化迭代器　　144
6.2.1 　迭代器块和yield return
简介　　145
6.2.2 　观察迭代器的工作流程　　146
6.2.3 　进一步了解迭代器执行流程　　148
6.2.4 　具体实现中的奇特之处　　151
6.3 　真实的迭代器示例　　152
6.3.1 　迭代时刻表中的日期　　152
6.3.2 　迭代文件中的行　　153
6.3.3 　使用迭代器块和谓词对项进行延迟过滤　　156
6.4 　使用CCR实现伪同步代码　　157
6.5 　小结　　160
第7章　结束C# 2的讲解：最后的一些
特性　　161
7.1 　分部类型　　162
7.1.1 　在多个文件中创建一个类型　　162
7.1.2 　分部类型的使用　　164
7.1.3 　C# 3独有的分部方法　　166
7.2 　静态类型　　167
7.3 　独立的取值方法/赋值方法属性访问
器　　169
7.4 　命名空间别名　　170
7.4.1 　限定的命名空间别名　　171
7.4.2 　全局命名空间别名　　172
7.4.3 　外部别名　　173
7.5 　pragma指令　　174
7.5.1 　警告pragma　　174
7.5.2 　校验和pragma　　175
7.6 　非安全代码中固定大小的缓冲区　　176
7.7 　把内部成员暴露给选定的程序集　　178
7.7.1 　简单情况下的友元程序集　　178
7.7.2 　为什么使用Internals-
VisibleTo　　179
7.7.3 　InternalsVisibleTo和签名程序集　　179
7.8 　小结　　180
第三部分　C# 3 ：革新写代码的方式
第8章　用智能的编译器来防错　　182
8.1 　自动实现的属性　　183
8.2 　隐式类型的局部变量　　185
8.2.1 　用var声明局部变量　　185
8.2.2 　隐式类型的限制　　187
8.2.3 　隐式类型的优缺点　　188
8.2.4 　建议　　189
8.3 　简化的初始化　　190
8.3.1 　定义示例类型　　190
8.3.2 　设置简单属性　　191
8.3.3 　为嵌入对象设置属性　　192
8.3.4 　集合初始化程序　　193
8.3.5 　初始化特性的应用　　196
8.4 　隐式类型的数组　　197
8.5 　匿名类型　　198
8.5.1 　第一次邂逅匿名类型　　198
8.5.2 　匿名类型的成员　　200
8.5.3 　投影初始化程序　　201
8.5.4 　重点何在　　202
8.6 　小结　　203
第9章　Lambda表达式和表达式树　　204
9.1 　作为委托的Lambda表达式　　205
9.1.1 　准备工作：Func<...>委托类型简介　　205
9.1.2 　第一次转换成Lambda表达式　　206
9.1.3 　用单一表达式作为主体　　207
9.1.4 　隐式类型的参数列表　　207
9.1.5 　单一参数的快捷语法　　208
9.2 　使用List<T>和事件的简单例子　　209
9.2.1 　列表的过滤、排序和操作　　210
9.2.2 　在事件处理程序中进行记录　　211
9.3 　表达式树　　212
9.3.1 　以编程方式构建表达式树　　213
9.3.2 　将表达式树编译成委托　　214
9.3.3 　将C# Lambda表达式转换成
表达式树　　215
9.3.4 　位于LINQ核心的表达式树　　218
9.3.5 　LINQ之外的表达式树　　220
9.4 　类型推断和重载决策的改变　　221
9.4.1 　改变的起因：精简泛型方法
调用　　221
9.4.2 　推断匿名函数的返回类型　　222
9.4.3 　分两个阶段进行的类型推断　　223
9.4.4 　选择正确的被重载的方法　　227
9.4.5 　类型推断和重载决策　　229
9.5 　小结　　229
第10章　扩展方法　　230
10.1 　未引入扩展方法之前的状态　　231
10.2 　扩展方法的语法　　233
10.2.1 　声明扩展方法　　233
10.2.2 　调用扩展方法　　234
10.2.3 　扩展方法是怎样被发现的　　235
10.2.4 　在空引用上调用方法　　236
10.3 　.NET 3.5中的扩展方法　　238
10.3.1 　从Enumerable开始起步　　238
10.3.2 　用Where过滤并将方法调
用链接到一起　　240
10.3.3 　插曲：似曾相识的Where
方法　　241
10.3.4 　用Select方法和匿名类型进行投影　　242
10.3.5 　用OrderBy方法进行排序　　243
10.3.6 　涉及链接的实际例子　　244
10.4 　使用思路和原则　　245
10.4.1 “扩展世界”和使接口更
丰富　　246
10.4.2 　流畅接口　　246
10.4.3 　理智使用扩展方法　　248
10.5 　小结　　249
第11章　查询表达式和LINQ to
Objects　　250
11.1 　LINQ介绍　　251
11.1.1 　LINQ中的基础概念　　251
11.1.2 　定义示例数据模型　　255
11.2 　简单的开始：选择元素　　256
11.2.1 　以数据源作为开始，以选择作为结束　　257
11.2.2 　编译器转译是查询表达式基础的转译　　257
11.2.3 　范围变量和重要的投影　　260
11.2.4 　Cast、OfType和显式类型的范围变量　　262
11.3 　对序列进行过滤和排序　　264
11.3.1 　使用where子句进行过滤　　264
11.3.2 　退化的查询表达式　　265
11.3.3 　使用orderby子句进行
排序　　265
11.4 　let子句和透明标识符　　267
11.4.1 　用let来进行中间计算　　267
11.4.2 　透明标识符　　268
11.5 　连接　　270
11.5.1 　使用join子句的内连接　　270
11.5.2 　使用join...into子句进行分组连接　　274
11.5.3 　使用多个from子句进行交
叉连接和合并序列　　276
11.6 　分组和延续　　279
11.6.1 　使用group...by子句进
行分组　　279
11.6.2 　查询延续　　282
11.7 　在查询表达式和点标记之间作出
选择　　285
11.7.1 　需要使用点标记的操作　　285
11.7.2 　使用点标记可能会更简单的查询表达式　　286
11.7.3 　选择查询表达式　　286
11.8 　小结　　287
第12章　超越集合的LINQ　　289
12.1 　使用LINQ to SQL查询数据库　　290
12.1.1 　数据库和模型　　290
12.1.2 　用查询表达式访问数据库　　292
12.1.3 　包含连接的查询　　294
12.2 　用IQueryable和IQueryProvider
进行转换　　296
12.2.1 　IQueryable<T>和相关接
口的介绍　　297
12.2.2 　模拟接口实现来记录调用　　298
12.2.3 　把表达式粘合在一起：Queryable的扩展方法　　300
12.2.4 　模拟实际运行的查询提
供器　　302
12.2.5 　包装IQueryable　　303
12.3 　LINQ友好的API和LINQ to XML　　303
12.3.1 　LINQ to XML中的核心
类型　　304
12.3.2 　声明式构造　　305
12.3.3 　查询单个节点　　308
12.3.4 　合并查询操作符　　309
12.3.5 　与LINQ和谐共处　　310
12.4 　用并行LINQ代替LINQ to Objects　　311
12.4.1 　在单线程中绘制曼德博罗
特集　　311
12.4.2 　ParallelEnumerable、ParallelQuery和AsParallel　　313
12.4.3 　调整并行查询　　315
12.5 　使用LINQ to Rx反转查询模型　　316
12.5.1 　IObservable<T>和IObserver<T>　　316
12.5.2 　简单的开始　　318
12.5.3 　查询可观察对象　　319
12.5.4 　意义何在　　321
12.6 　扩展LINQ to Objects　　321
12.6.1 　设计和实现指南　　322
12.6.2 　示例扩展：选择随机元素　　323
12.7 　小结　　324
第四部分　C# 4 ：良好的交互性
第13章　简化代码的微小修改　　328
13.1 　可选参数和命名实参　　328
13.1.1 　可选参数　　329
13.1.2 　命名实参　　334
13.1.3 　两者相结合　　337
13.2 　改善COM互操作性　　341
13.2.1 　在C# 4之前操纵Word是
十分恐怖的　　342
13.2.2 　可选参数和命名实参的
复仇　　342
13.2.3 　按值传递ref参数　　343
13.2.4 　调用命名索引器　　344
13.2.5 　链接主互操作程序集　　345
13.3 　接口和委托的泛型可变性　　348
13.3.1 　可变性的种类：协变性和逆变性　　348
13.3.2 　在接口中使用可变性　　349
13.3.3 　在委托中使用可变性　　352
13.3.4 　复杂情况　　353
13.3.5 　限制和说明　　354
13.4 　对锁和字段风格的事件的微小改变　　357
13.4.1 　健壮的锁　　357
13.4.2 　字段风格的事件　　358
13.5 　小结　　359
第14章　静态语言中的动态绑定　　360
14.1 　何谓、何时、为何、如何　　361
14.1.1 　何谓动态类型　　361
14.1.2 　动态类型什么时候有用，为什么　　362
14.1.3 　C# 4如何提供动态类型　　363
14.2 　关于动态的快速指南　　364
14.3 　动态类型示例　　366
14.3.1 　COM和Office　　367
14.3.2 　动态语言　　368
14.3.3 　纯托管代码中的动态类型　　372
14.4 　幕后原理　　377
14.4.1 　DLR简介　　378
14.4.2 　DLR核心概念　　379
14.4.3 　C#编译器如何处理动态　　382
14.4.4 　更加智能的C#编译器　　385
14.4.5 　动态代码的约束　　388
14.5 　实现动态行为　　390
14.5.1 　使用ExpandoObject　　391
14.5.2 　使用DynamicObject　　394
14.5.3　　实现IDynamicMetaObject-
Provider　　400
14.6 　小结　　404
第五部分　C# 5：简化的异步编程
第15章　使用async/await进行异步
编程　　406
15.1 　异步函数简介　　407
15.1.1 　初识异步类型　　408
15.1.2 　分解第一个示例　　409
15.2 　思考异步编程　　410
15.2.1 　异步执行的基础　　410
15.2.2 　异步方法　　412
15.3 　语法和语义　　413
15.3.1 　声明异步方法　　413
15.3.2 　异步方法的返回类型　　414
15.3.3 　可等待模式　　415
15.3.4 　await表达式的流　　418
15.3.5 　从异步方法返回　　421
15.3.6 　异常　　422
15.4 　异步匿名函数　　429
15.5 　实现细节：编译器转换　　431
15.5.1 　生成的代码　　432
15.5.2 　骨架方法的结构　　434
15.5.3 　状态机的结构　　435
15.5.4 　一个入口搞定一切　　436
15.5.5 　围绕await表达式的控制　　438
15.5.6 　跟踪栈　　439
15.5.7 　更多内容　　440
15.6 　高效地使用async/await　　441
15.6.1 　基于任务的异步模式　　441
15.6.2 　组合异步操作　　444
15.6.3 　对异步代码编写单元测试　　447
15.6.4 　可等待模式的归来　　450
15.6.5 　在WinRT中执行异步操作　　451
15.7 　小结　　452
第16章　C# 5附加特性和结束语　　453
16.1 　foreach循环中捕获变量的变化　　453
16.2 　调用者信息特性　　454
16.2.1 　基本行为　　454
16.2.2 　日志　　456
16.2.3 　实现INotifyProperty-
Changed　　456
16.2.4 　在非.NET 4.5环境下使用调用者信息特性　　457
16.3 　结束语　　458
附录A 　LINQ标准查询操作符　　460
附录B 　.NET中的泛型集合　　471
附录C 　版本总结　　483

## 下载 ##

+ [百度云下载](http://pan.baidu.com/s/1pJ7qIDH)
+ [微盘下载](http://vdisk.weibo.com/s/aADaW4YRFB2zD)
+ [FilePi下载](http://filepi.com/i/bmN5hpn)
+ [千易下载](http://1000eb.com/1drkw)

<!-- 2e
+ [微盘下载](http://vdisk.weibo.com/s/aADaW4YRFwAmH)
+ [百度云下载](http://pan.baidu.com/s/1o6n6Qcq)
+ [MEGA下载](https://mega.co.nz/#!3VNhiYCZ!9X8jQcecLxlOEuoVcVI2oLmpUKWeZwSe7BCTjRRCfus)
-->
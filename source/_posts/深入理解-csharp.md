title: 深入理解 c# （中文第二版）
date: 2015-05-23 15:42:10
categories:
  - csharp
---

格式：PDF
类型：扫描版
大小：14.8M

<!--more-->

## 出版信息 ##

作者: Jon Skeet 
出版社: 人民邮电出版社
原作名: C# in Depth, Second Edition
译者: 周靖 / 朱永光 / 姚琪琳 
出版年: 2012-1
页数: 445
定价: 79.00元
装帧: 平装
ISBN: 9787115269249

## 简介 ##

《深入理解C#(第2版)》是C#领域不可多得的经典著作。作者Jon Skeet在详尽地展示C#各个知识点的同时，更注重从现象中挖掘本质。本书深入探索了C#的核心概念和经典特性，并将这些特性融入到代码中，让读者能够真正领会到C#之“深入”与“精妙”。在第1版的基础上，书中新增了C# 4的新特性，如动态类型、命名实参和可选参数等，这些特性将C#语言提升到了一个新的层次。
《深入理解C#(第2版)》适合中高级.NET开发人员阅读。

## 目录 ##

第一部分 基础知识
第1 章 C#开发的进化史　　 2
1.1 从简单的数据类型开始　　 3
1.1.1 C# 1 中定义的产品类型　　 3
1.1.2 C# 2 中的强类型集合　　4
1.1.3 C# 3 中自动实现的属性　　 5
1.1.4 C# 4 中的命名实参　　 6
1.2 排序和过滤　　 7
1.2.1 按名称对产品进行排序　　 7
1.2.2 查询集合　　 10
1.3 处理未知数据　　 11
1.3.1 表示未知的价格　　 12
1.3.2 可选参数和默认值　　 12
1.4 LINQ 简介　　 13
1.4.1 查询表达式和进程内查询　　 13
1.4.2 查询XML　　 14
1.4.3 LINQ to SQL 　　 15
1.5 COM 和动态类型　　 16
1.5.1 简化COM 互操作　　 16
1.5.2 与动态语言互操作　　 17
1.6 剖析.NET 平台　　 18
1.6.1 C#语言　　 18
1.6.2 运行时　　 19
1.6.3 框架库　　 19
1.7 怎样写出超炫的代码　　 19
1.7.1 采用代码段形式的全能代码　　 20
1.7.2 教学代码不是产品代码　　 21
1.7.3 你的新朋友：语言规范　　 21
1.8 小结　　 21
第2 章 C# 1 所搭建的核心基础　　 23
2.1 委托　　 23
2.1.1 简单委托的构成　　 24
2.1.2 合并和删除委托　　 28
2.1.3 对事件的简单讨论　　 29
2.1.4 委托小结　　 30
2.2 类型系统的特征　　 31
2.2.1 C#在类型系统世界中的位置　　 31
2.2.2 C# 1 的类型系统在什么时候不够用　　 34
2.2.3 类型系统特征总结　　 36
2.3 值类型和引用类型　　 36
2.3.1 现实世界中的值和引用　　 36
2.3.2 值类型和引用类型基础知识　　 37
2.3.3 走出误区　　 38
2.3.4 装箱和拆箱　　 40
2.3.5 值类型和引用类型小结　　 41
2.4 C# 1 之外：构建于坚实基础之上的新特性　　 41
2.4.1 与委托有关的特性　　 41
2.4.2 与类型系统有关的特性　　 43
2.4.3 与值类型有关的特性　　 45
2.5 小结　　 46
第二部分 C# 2：解决C# 1 的问题
第3 章 用泛型实现参数化类型　　 48
3.1 为什么需要泛型　　 49
3.2 日常使用的简单泛型　　 50
3.2.1 通过例子来学习：泛型字典　　 50
3.2.2 泛型类型和类型参数　　 52
3.2.3 泛型方法和判读泛型声明　　 55
3.3 深化与提高　　 58
3.3.1 类型约束　　 58
3.3.2 泛型方法类型实参的类型推断　　 62
3.3.3 实现泛型　　 63
3.4 高级泛型　　 68
3.4.1 静态字段和静态构造函数　　 69
3.4.2 JIT 编译器如何处理泛型　　 70
3.4.3 泛型迭代　　 72
3.4.4 反射和泛型　　 74
3.5 泛型在C#和其他语言中的限制　　 78
3.5.1 泛型可变性的缺乏　　 78
3.5.2 缺乏操作符约束或者“数值”约束　　 82
3.5.3 缺乏泛型属性、索引器和其他成员类型　　 83
3.5.4 同C++模板的对比　　 84
3.5.5 和Java 泛型的对比　　 85
3.6 小结　　 86
第4 章 可空类型　　 88
4.1 没有值时怎么办　　 88
4.1.1 为什么值类型的变量不能是null 　　 89
4.1.2 在C# 1 中表示空值的模式　　 89
4.2 System.Nullable<T>和System.Nullable 　　 91
4.2.1 Nullable<T>简介　　 91
4.2.2 Nullable<T>装箱和拆箱　　 94
4.2.3 Nullable<T>实例的相等性　　 95
4.2.4 来自非泛型Nullable 类的支持　　 96
4.3 C# 2 为可空类型提供的语法糖　　 96
4.3.1 ?修饰符　　 97
4.3.2 使用null 进行赋值和比较　　 98
4.3.3 可空转换和操作符　　 99
4.3.4 可空逻辑　　 102
4.3.5 对可空类型使用as 操作符　　 103
4.3.6 空合并操作符　　 104
4.4 可空类型的新奇用法　　 106
4.4.1 尝试一个不使用输出参数的操作　　 107
4.4.2 空合并操作符让比较不再痛苦　　 108
4.5 小结　　 111
第5 章 进入快速通道的委托　　 112
5.1 向笨拙的委托语法说拜拜　　 113
5.2 方法组转换　　 114
5.3 协变性和逆变性　　 115
5.3.1 委托参数的逆变性　　 116
5.3.2 委托返回类型的协变性　　 117
5.3.3 不兼容的风险　　 118
5.4 使用匿名方法的内联委托操作　　 119
5.4.1 从简单的开始：处理一个参数　　 119
5.4.2 匿名方法的返回值　　 121
5.4.3 忽略委托参数　　 123
5.5 在匿名方法中捕捉变量　　 124
5.5.1 定义闭包和不同的变量类型　　 124
5.5.2 测试被捕获的变量的行为　　 126
5.5.3 捕获变量到底有什么用处　　 127
5.5.4 捕获变量的延长生存期　　 127
5.5.5 局部变量实例化　　 128
5.5.6 共享和非共享的变量混合使用　　 130
5.5.7 捕获变量的使用规则和小结　　 132
5.6 小结　　 133
第6 章 实现迭代器的捷径　　 134
6.1 C# 1：手写迭代器的痛苦　　 135
6.2 C# 2：利用yield 语句简化迭代器　　 137
6.2.1 迭代器块和yield return简介　　 137
6.2.2 观察迭代器的工作流程　　 139
6.2.3 进一步了解迭代器执行流程　　 141
6.2.4 具体实现中的奇特之处　　 144
6.3 真实的例子：迭代范围值　　 145
6.3.1 迭代时刻表中的日期　　 145
6.3.2 迭代文件中的行　　 146
6.3.3 使用迭代器块和谓词对项进行延迟筛选　　 148
6.4 使用CCR 实现伪同步代码　　 150
6.5 小结　　 152
第7 章 结束C# 2 的讲解：最后的一些特性　　 153
7.1 分部类型　　154
7.1.1 在多个文件中创建一个类型　　 154
7.1.2 分部类型的使用　　 156
7.1.3 C# 3 独有的分部方法　　 157
7.2 静态类型　　 159
7.3 独立的取值方法/赋值方法属性访问器　　161
7.4 命名空间别名　　162
7.4.1 限定的命名空间别名　　 163
7.4.2 全局命名空间别名　　 164
7.4.3 外部别名　　 164
7.5 Pragma 指令　　 166
7.5.1 警告pragma　　 166
7.5.2 校验和pragma　　 167
7.6 非安全代码中的固定大小的缓冲区　　 167
7.7 把内部成员暴露给选定的程序集　　 169
7.7.1 在简单情况下的友元程序集　　 169
7.7.2 为什么使用InternalsVisibleTo 　　 170
7.7.3 InternalsVisibleTo 和签名程序集　　 170
7.8 小结　　 171
第三部分 C# 3：革新写代码的方式
第8 章 用智能的编译器来防错　　 174
8.1 自动实现的属性　　 175
8.2 隐式类型的局部变量　　 176
8.2.1 用var 声明局部变量　　 177
8.2.2 隐式类型的限制　　 178
8.2.3 隐式类型的优缺点　　 179
8.2.4 建议　　 180
8.3 简化的初始化　　 180
8.3.1 定义示例类型　　 181
8.3.2 设置简单属性　　 182
8.3.3 为嵌入对象设置属性　　 183
8.3.4 集合初始化列表　　 184
8.3.5 初始化特性的应用　　 186
8.4 隐式类型的数组　　 187
8.5 匿名类型　　 188
8.5.1 第一次邂逅匿名类型　　 188
8.5.2 匿名类型的成员　　 190
8.5.3 投影初始化列表　　 191
8.5.4 重点何在　　 192
8.6 小结　　193
第9 章 Lambda 表达式和表达式树　　 194
9.1 作为委托的Lambda 表达式　　 195
9.1.1 准备工作：Func<　　>委托类型简介　　 195
9.1.2 第一次转换成Lambda表达式　　 196
9.1.3 用单一表达式作为主体　　 197
9.1.4 隐式类型的参数列表　　 197
9.1.5 单一参数的快捷语法　　 198
9.2 使用List<T>和事件的简单例子　　 199
9.2.1 对列表进行筛选、排序并设置其他操作　　 199
9.2.2 在事件处理程序中进行记录　　 201
9.3 表达式树　　 202
9.3.1 在程序中构建表达式树　　 202
9.3.2 将表达式树编译成委托　　 204
9.3.3 将C# Lambda 表达式转换成表达式树　　 205
9.3.4 位于LINQ 核心的表达式树　　 208
9.3.5 LINQ 之外的表达式树　　 209
9.4 类型推断和重载决策发生的改变　　 211
9.4.1 改变的起因：精简泛型方法调用　　 211
9.4.2 推断匿名函数的返回类型　　 212
9.4.3 分两个阶段进行的类型推断　　 213
9.4.4 选择正确的被重载的方法　　 217
9.4.5 类型推断和重载决策　　 218
9.5 小结　　 219
第10 章 扩展方法　　 220
10.1 未引入扩展方法之前的状态　　 221
10.2 扩展方法的语法　　 223
10.2.1 声明扩展方法　　 223
10.2.2 调用扩展方法　　 224
10.2.3 扩展方法是怎样被发现的　　 225
10.2.4 在空引用上调用方法　　 226
10.3 . NET 3.5 中的扩展方法　　 227
10.3.1 从Enumerable 开始起步　　 228
10.3.2 用Where 筛选并将方法调用链接到一起　　 229
10.3.3 插曲：似曾相识的Where方法　　 231
10.3.4 用Select 方法和匿名类型进行投影　　 232
10.3.5 用OrderBy 方法进行排序　　 232
10.3.6 涉及链接的实际例子　　 234
10.4 使用思路和原则　　 235
10.4.1 “扩展世界”和使接口更丰富　　 235
10.4.2 流畅接口　　 236
10.4.3 理智使用扩展方法　　 237
10.5 小结　　 238
第11 章 查询表达式和LINQ to Objects 　　 240
11.1 LINQ 介绍　　 241
11.1.1 LINQ 中的基础概念　　 241
11.1.2 定义示例数据模型　　 245
11.2 简单的开始：选择元素　　 246
11.2.1 以数据源作为开始，以选择作为结束　　 246
11.2.2 作为查询表达式基础的编译器转换　　 247
11.2.3 范围变量和重要的投影　　 249
11.2.4 Cast、OfType 和显式类型的范围变量　　 251
11.3 对序列进行过滤和排序　　 252
11.3.1 使用where 子句进行过滤　　 253
11.3.2 退化的查询表达式　　 253
11.3.3 使用orderby 子句进行排序　　 254
11.4 let 子句和透明标识符　　 256
11.4.1 用let 来进行中间计算　　 256
11.4.2 透明标识符　　 257
11.5 联接　　 258
11.5.1 使用join 子句的内联接　　 258
11.5.2 使用join　　into 子句进行分组联接　　 262
11.5.3 使用多个from 子句进行交叉联接和合并序列　　 264
11.6 分组和延续　　 267
11.6.1 使用group　　by 子句进行分组　　 267
11.6.2 查询延续　　 270
11.7 在查询表达式和点标记之间作出选择　　 272
11.7.1 需要使用点标记的操作　　 273
11.7.2 选择点标记　　 273
11.7.3 选择查询表达式　　 274
11.8 小结　　 275
第12 章 超越集合的LINQ　　 276
12.1 使用LINQ to SQL 查询数据库　　 277
12.1.1 数据库和模型　　 277
12.1.2 用查询表达式访问数据库　　 279
12.1.3 包含联接的查询　　 281
12.2 用IQueryable 和IQueryProvider 进行转换　　 283
12.2.1 IQueryable<T>和相关接口的介绍　　 283
12.2.2 模拟接口实现来记录调用　　 285
12.2.3 把表达式粘合在一起：Queryable 的扩展方法　　 287
12.2.4 模拟实际运行的查询提供器　　 289
12.2.5 包装IQueryable　　 290
12.3 LINQ 友好的API 和LINQ to XML　　 290
12.3.1 LINQ to XML 中的核心类型　　 290
12.3.2 声明式构造　　 292
12.3.3 查询单个节点　　 294
12.3.4 合并查询操作符　　 296
12.3.5 与LINQ 和谐共处　　 297
12.4 用并行LINQ 代替LINQ to Objects　　 297
12.4.1 在单线程中绘制曼德博罗特集　　 297
12.4.2 ParallelEnumerable、Parallel-Query 和AsParallel 　　 299
12.4.3 调整并行查询　　 300
12.5 使用LINQ to Rx 反转查询模型　　 301
12.5.1 IObservable<T>和IObserver<T>　　 302
12.5.2 简单地开始　　 303
12.5.3 查询可观察对象　　304
12.5.4 意义何在　　 306
12.6 扩展LINQ to Objects　　 306
12.6.1 设计和实现指南　　 307
12.6.2 示例扩展：选择随机元素　　 308
12.7 小结　　 309
第四部分 C# 4：良好的交互性
第13 章 简化代码的微小修改　　 312
13.1 可选参数和命名实参　　 312
13.1.1 可选参数　　 313
13.1.2 命名实参　　 317
13.1.3 两者相结合　　 321
13.2 改善COM 互操作性　　 324
13.2.1 在C# 4 之前操纵Word是十分恐怖的　　 325
13.2.2 可选参数和命名实参的复仇　　 325
13.2.3 按值传递ref 参数　　 326
13.2.4 调用命名索引器　　 327
13.2.5 链接主互操作程序集　　 328
13.3 接口和委托的泛型可变性　　 330
13.3.1 可变性的种类：协变性和逆变性　　331
13.3.2 在接口中使用可变性　　 332
13.3.3 在委托中使用可变性　　 334
13.3.4 复杂情况　　 335
13.3.5 限制和说明　　 336
13.4 对锁和字段风格的事件的微小改变　　 339
13.4.1 健壮的锁　　 339
13.4.2 字段风格的事件　　 340
13.5 小结　　 341
第14 章 静态语言中的动态绑定　　 342
14.1 何谓，何时，为何，如何　　 343
14.1.1 何谓动态类型　　 343
14.1.2 动态类型什么时候有用，为什么　　 344
14.1.3 C# 4 如何提供动态类型　　 345
14.2 关于动态的快速指南　　 345
14.3 动态类型示例　　 348
14.3.1 COM 和Office 　　 348
14.3.2 动态语言　　 350
14.3.3 纯托管代码中的动态类型　　 353
14.4 幕后原理　　 358
14.4.1 DLR 简介　　 358
14.4.2 DLR 核心概念　　 360
14.4.3 C#编译器如何处理动态　　 362
14.4.4 更加智能的C#编译器　　 365
14.4.5 动态代码的约束　　 368
14.5 实现动态行为　　 370
14.5.1 使用ExpandoObject　　 370
14.5.2 使用DynamicObject　　 374
14.5.3 实现IDynamicMetaObject-Provider　　 380
14.6 小结　　383
第15 章 使用契约让代码更加清晰　　 385
15.1 未引入代码契约之前的状态　　 386
15.2 代码契约　　 387
15.2.1 前置条件　　 388
15.2.2 后置条件　　 389
15.2.3 固定条件　　 390
15.2.4 断言和假设　　 392
15.2.5 旧式契约　　 393
15.3 使用ccrewrite 和ccrefgen 重写二进制　　 394
15.3.1 简单重写　　 394
15.3.2 契约继承　　 395
15.3.3 契约引用程序集　　 398
15.3.4 失败行为　　 399
15.4 静态检查　　 401
15.4.1 开始静态检查　　 401
15.4.2 隐式职责　　 403
15.4.3 有选择性的检查　　 406
15.5 使用ccdocgen 将契约文档化　　 408
15.6 契约实战　　 410
15.6.1 契约中有什么　　 410
15.6.2 如何开始　　 411
15.6.3 无处不在的选项　　 412
15.7 小结　　 414
第16 章 何去何从　　 415
16.1 C#——传统与现代的结合　　 415
16.2 计算机科学和.NET　　 416
16.3 计算机世界　　 417
16.4 再会　　 417
附录A LINQ 标准查询操作符　　 419
附录B .NET 中的泛型集合　　 430
附录C 版本总结　　 440

## 下载 ##

+ [微盘下载](http://vdisk.weibo.com/s/aADaW4YRFwAmH)
+ [百度云下载](http://pan.baidu.com/s/1o6n6Qcq)
+ [MEGA下载](https://mega.co.nz/#!3VNhiYCZ!9X8jQcecLxlOEuoVcVI2oLmpUKWeZwSe7BCTjRRCfus)
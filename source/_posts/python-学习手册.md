title: python 学习手册 （中文第四版）
date: 2015-05-21 11:24:08
categories:
  - python
---

![](http://img3.douban.com/lpic/s4683230.jpg)

格式：EPUB
类型：文字版

<!--more-->

## 出版信息 ##

作者: [美] Mark Lutz 
出版社: 机械工业出版社
原作名: Learning Python, Fourth Edition
译者: 李军 / 刘红伟 
出版年: 2011-4
页数: 889
定价: 119.00元
装帧: 平装
ISBN: 9787111326533

## 简介 ##

Google和YouTube由于Python的高可适应性、易于维护以及适合于快速开发而采用它。如果你想要编写高质量、高效的并且易于与其他语言和工具集成的代码，《Python学习手册：第4 版》将帮助你使用Python快速实现这一点，不管你是编程新手还是Python初学者。本书是易于掌握和自学的教程，根据作者Python专家Mark Lutz的著名培训课程编写而成。
《Python学习手册：第4版》每一章都包含关于Python语言的关键内容的独立的一课，并且包含了一个独特的“练习题”部分，其中带有实际的练习和测试，以便你可以练习新的技能并随着学习而测试自己的理解。你会发现众多带有注释的示例以及图表，它们将帮助你开始学习Python 3.0。

## 目录 ##

前言	1
第一部分 使用入门
第1章 问答环节	19
人们为何使用Python	19
软件质量	20
开发效率	21
Python是“脚本语言”吗	21
好吧，Python的缺点是什么呢	23
如今谁在使用Python	23
使用Python可以做些什么	24
系统编程	25
用户图形接口	25
Internet脚本	25
组件集成	26
数据库编程	26
快速原型	27
数值计算和科学计算编程	27
游戏、图像、人工智能、XML、机器人等	27
Python如何获得支持	28
Python有哪些技术上的优点	28
面向对象	28
免费	29
可移植	29
功能强大	30
可混合	31
简单易用	31
简单易学	32
Python和其他语言比较起来怎么样	32
本章小结	33
本章习题	33
习题解答	34
Python是工程，不是艺术	34
第2章 Python如何运行程序	36
Python解释器简介	36
程序执行	37
程序员的视角	37
Python的视角	39
执行模块的变体	41
Python实现的替代者	42
执行优化工具	43
冻结二进制文件	44
其他执行选项	45
未来的可能性	46
本章小结	46
本章习题	47
习题解答	47
第3章 如何运行程序	48
交互提示模式下编写代码	48
交互地运行代码	49
为什么使用交互提示模式	51
使用交互提示模式	52
系统命令行和文件	54
第一段脚本	55
使用命令行运行文件	56
使用命令行和文件	57
UNIX可执行脚本(#!)	58
UNIX env查找技巧	59
点击文件图标	60
在Windows中点击图标	60
input的技巧	61
图标点击的其他限制	63
模块导入和重载	63
模块的显要特性：属性	65
import和reload的使用注意事项	68
使用exec运行模块文件	69
IDLE用户界面	70
IDLE基础	71
使用IDLE	72
高级IDLE工具	74
其他的IDE	74
其他启动选项	76
嵌入式调用	76
冻结二进制的可执行性	77
文本编辑器启动的选择	77
其他的启动选择	77
未来的可能	77
我应该选用哪种	78
调试Python代码	78
本章小结	80
本章习题	80
习题解答	80
第一部分 练习题	81
第二部分 类型和运算
第4章 介绍Python对象类型	87
为什么使用内置类型	88
Python的核心数据类型	88
数字	90
字符串	92
序列的操作	92
不可变性	94
类型特定的方法	94
寻求帮助	96
编写字符串的其他方法	97
模式匹配	98
列表	98
序列操作	98
类型特定的操作	99
边界检查	100
嵌套	100
列表解析	101
字典	103
映射操作	103
重访嵌套	104
键的排序：for 循环	105
迭代和优化	107
不存在的键：if 测试	107
元组	109
为什么要用元组	109
文件	110
其他文件类工具	111
其他核心类型	111
如何破坏代码的灵活性	113
用户定义的类	114
剩余的内容	115
本章小结	115
本章习题	116
习题解答	116
第5章 数字	117
Python的数字类型	117
数字常量	118
内置数学工具和扩展	119
Python表达式操作符	120
在实际应用中的数字	125
变量和基本的表达式	125
数字显示的格式	126
比较：一般的和连续的	127
str和repr显示格式	128
除法： 传统除法、Floor除法和真除法	129
整数精度	133
复数	133
十六进制、八进制和二进制记数	134
位操作	136
其他的内置数学工具	137
其他数字类型	139
小数数字	139
分数类型	141
集合	145
布尔型	151
数字扩展	152
本章小结	153
本章习题	153
习题解答	153
第6章 动态类型简介	155
缺少类型声明语句的情况	155
变量、对象和引用	156
类型属于对象，而不是变量	157
对象的垃圾收集	158
共享引用	159
共享引用和在原处修改	161
共享引用和相等	163
动态类型随处可见	164
本章小结	165
本章习题	165
习题解答	165
第7章 字符串	167
字符串常量	169
单双引号字符串是一样的	170
用转义序列代表特殊字节	171
raw字符串抑制转义	173
三重引号编写多行字符串块	175
实际应用中的字符串	176
基本操作	176
索引和分片	177
为什么要在意：分片	181
字符串转换工具	181
修改字符串	184
字符串方法	185
字符串方法实例：修改字符串	187
字符串方法实例：文本解析	189
实际应用中的其他常见字符串方法	190
最初的字符串模块（在Python 3.0中删除）	191
字符串格式化表达式	192
更高级的字符串格式化表达式	194
基于字典的字符串格式化	196
字符串格式化调用方法	196
基础知识	197
添加键、属性和偏移量	198
添加具体格式化	198
与%格式化表达式比较	200
为什么用新的格式化方法	203
通常意义下的类型分类	206
同样分类的类型共享其操作集合	206
可变类型能够在原处修改	207
本章小结	208
本章习题	208
习题解答	208
第8章 列表与字典	210
列表	210
实际应用中的列表	213
基本列表操作	213
列表迭代和解析	213
索引、分片和矩阵	214
原处修改列表	215
字典	220
实际应用中的字典	222
字典的基本操作	222
原处修改字典	223
其他字典方法	224
语言表	225
字典用法注意事项	226
为什么要在意字典接口	229
创建字典的其他方法	230
Python 3.0中的字典变化	231
本章小结	237
本章习题	237
习题解答	237
第9章 元组、文件及其他	239
元组	239
实际应用中的元组	241
为什么有了列表还要元组	243
文件	243
打开文件	244
使用文件	245
实际应用中的文件	246
其他文件工具	252
重访类型分类	254
为什么要在意操作符重载	255
对象灵活性	255
引用 VS 拷贝	256
比较、相等性和真值	258
Python 3.0的字典比较	260
Python中真和假的含义	261
Python的类型层次	263
Type对象	263
Python中的其他类型	265
内置类型陷阱	265
赋值生成引用，而不是拷贝	265
重复能够增加层次深度	266
留意循环数据结构	266
不可变类型不可以在原处改变	267
本章小结	267
本章习题	268
习题解答	268
第二部分练习题	269
第三部分 语句和语法
第10章 Python语句简介	275
重访Python程序结构	275
Python的语句	276
两个if的故事	278
Python增加了什么	279
Python删除了什么	279
为什么使用缩进语法	281
几个特殊实例	283
简短实例：交互循环	285
一个简单的交互式循环	285
对用户输入数据做数学运算	287
用测试输入数据来处理错误	288
用try语句处理错误	289
嵌套代码三层	290
本章小结	290
本章习题	291
习题解答	291
第11章 赋值、表达式和打印	292
赋值语句	292
赋值语句的形式	293
序列赋值	294
Python 3.0中的扩展序列解包	297
多目标赋值语句	301
增强赋值语句	302
变量命名规则	305
Python的废弃协议	306
表达式语句	308
表达式语句和在原处的修改	309
打印操作	310
Python 3.0的print函数	311
Python 2.6 print语句	313
打印流重定向	315
版本独立的打印	318
为什么要注意print和stdout	319
本章小结	320
本章习题	321
习题解答	321
第12章 if测试和语法规则	322
if语句	322
通用格式	322
基本例子	323
多路分支	323
Python语法规则	325
代码块分隔符	326
语句的分隔符	328
一些特殊情况	329
真值测试	330
if/else三元表达式	332
为什么要在意布尔值	334
本章小结	335
本章习题	335
习题解答	335
第13章 while和for循环	336
while循环	336
一般格式	336
例子	337
break、continue、pass和循环else	338
一般循环格式	338
pass	338
continue	340
break	340
循环else	341
为什么要在意“模拟C 语言的while循环”	342
for循环	343
一般格式	343
例子	344
为什么要在意“文件扫描”	349
编写循环的技巧	350
循环计数器：while和range	351
非完备遍历：range和分片	352
修改列表：range	353
并行遍历：zip和map	354
产生偏移和元素：enumerate	357
本章小结	358
本章习题	358
习题解答	359
第14章 迭代器和解析，第一部分	360
迭代器：初探	360
文件迭代器	361
手动迭代：iter和next	363
其他内置类型迭代器	365
列表解析：初探	367
列表解析基础知识	368
在文件上使用列表解析	369
扩展的列表解析语法	370
其他迭代环境	371
Python 3.0中的新的可迭代对象	375
range迭代器	376
map、zip和filter迭代器	377
多个迭代器 VS单个迭代器	378
字典视图迭代器	379
其他迭代器主题	381
本章小结	381
本章习题	381
习题解答	382
第15章 文档	383
Python文档资源	383
#注释	384
dir函数	384
文档字符串：__doc__	385
PyDoc：help函数	388
PyDoc：HTML报表	390
标准手册集	393
网络资源	394
已出版的书籍	394
常见编写代码的陷阱	395
本章小结	397
本章习题	397
习题解答	397
第三部分练习题	398
第四部分 函数
第16章 函数基础	403
为何使用函数	404
编写函数	405
def语句	406
def语句是实时执行的	407
第一个例子：定义和调用	408
定义	408
调用	408
Python中的多态	409
第二个例子：寻找序列的交集	410
定义	410
调用	411
重访多态	411
本地变量	412
本章小结	413
本章习题	413
习题解答	413
第17章 作用域	415
Python作用域基础	415
作用域法则	416
变量名解析：LEGB原则	418
作用域实例	419
内置作用域	420
在Python 2.6中违反通用性	422
global语句	422
最小化全局变量	423
最小化文件间的修改	424
其他访问全局变量的方法	426
作用域和嵌套函数	427
嵌套作用域的细节	427
嵌套作用域举例	427
nonlocal语句	433
nonlocal基础	433
nonlocal应用	435
为什么使用nonlocal	437
本章小结	440
本章习题	441
习题解答	442
第18章 参数	444
传递参数	444
参数和共享引用	445
避免可变参数的修改	447
对参数输出进行模拟	448
特定的参数匹配模型	449
基础知识	449
匹配语法	450
细节	452
关键字参数和默认参数的实例	452
任意参数的实例	455
Python 3.0 Keyword-Only参数	459
min调用	462
满分	463
加分点	464
结论	465
一个更有用的例子：通用set函数	465
模拟Python 3.0 print函数	466
使用Keyword-Only参数	467
为什么要在意：关键字参数	469
本章小结	469
本章习题	470
习题解答	470
第19章 函数的高级话题	472
函数设计概念	472
递归函数	474
用递归求和	474
编码替代方案	475
循环语句VS递归	476
处理任意结构	477
函数对象：属性和注解	478
间接函数调用	478
函数内省	479
函数属性	480
Python 3.0中的函数注解	481
匿名函数： lambda	483
lambda表达式	483
为什么使用lambda	484
如何（不要）让Python代码变得晦涩难懂	486
嵌套lambda和作用域	487
为什么要在意：回调	488
在序列中映射函数：map	489
函数式编程工具：filter和reduce	490
本章小结	492
本章习题	492
习题解答	492
第20章 迭代和解析，第二部分	494
回顾列表解析：函数式编程工具	494
列表解析与map	495
增加测试和嵌套循环	496
列表解析和矩阵	498
理解列表解析	499
为什么要在意：列表解析和map	500
重访迭代器：生成器	501
生成器函数：yield VS return	502
生成器表达式：迭代器遇到列表解析	506
生成器函数 VS 生成器表达式	507
生成器是单迭代器对象	508
用迭代工具模拟zip和map	510
为什么你会留意：单次迭代	514
内置类型和类中的值生成	515
Python 3.0解析语法概括	516
解析集合和字典解析	517
针对集合和字典的扩展的解析语法	517
对迭代的各种方法进行计时	518
对模块计时	519
计时脚本	519
计时结果	520
计时模块替代方案	523
其他建议	527
函数陷阱	528
本地变量是静态检测的	528
默认和可变对象	529
没有return语句的函数	531
嵌套作用域的循环变量	532
本章小结	532
本章习题	532
习题解答	533
第四部分练习题	533
第五部分 模块
第21章 模块：宏伟蓝图	539
为什么使用模块	540
Python程序架构	540
如何组织一个程序	541
导入和属性	541
标准库模块	543
import如何工作	543
1.搜索	544
2.编译（可选）	544
3.运行	545
模块搜索路径	545
配置搜索路径	547
搜索路径的变动	548
sys.path列表	548
模块文件选择	549
高级的模块选择概念	550
第三方工具：distutils	550
本章小结	551
本章习题	551
习题解答	551
第22章 模块代码编写基础	553
模块的创建	553
模块的使用	554
import语句	554
from语句	555
from *语句	555
导入只发生一次	555
import和from是赋值语句	556
文件间变量名的改变	557
import和from的对等性	557
from语句潜在的陷阱	558
模块命名空间	560
文件生成命名空间	560
属性名的点号运算	562
导入和作用域	562
命名空间的嵌套	563
重载模块	564
reload基础	565
reload实例	566
为什么要在意：模块重载	567
本章小结	568
本章习题	568
习题解答	568
第23章 模块包	570
包导入基础	570
包和搜索路径设置	571
__init__.py包文件	572
包导入实例	573
包对应的from语句和import语句	574
为什么要使用包导入	575
三个系统的传说	576
包相对导入	578
Python 3.0中的变化	578
相对导入基础知识	579
为什么使用相对导入	581
相对导入的作用域	583
模块查找规则总结	583
相对导入的应用	584
为什么要在意：模块包	589
本章小结	590
本章习题	590
习题解答	590
第24章 高级模块话题	592
在模块中隐藏数据	592
最小化from *的破坏：_X和__all__	593
启用以后的语言特性	593
混合用法模式：__name__和__main__	594
以__name__进行单元测试	595
使用带有__name__的命令行参数	596
修改模块搜索路径	599
Import语句和from语句的as扩展	599
模块是对象：元程序	600
用名称字符串导入模块	603
过渡性模块重载	604
模块设计理念	607
模块陷阱	607
顶层代码的语句次序的重要性	608
from复制变量名，而不是连接	609
from *会让变量语义模糊	610
reload不会影响from导入	610
reload、from以及交互模式测试	611
递归形式的from导入无法工作	612
本章小结	613
本章习题	613
习题解答	613
第五部分练习题	614
第六部分 类和OOP
第25章 OOP：宏伟蓝图	619
为何使用类	620
概览OOP	621
属性继承搜索	621
类和实例	623
类方法调用	624
编写类树	624
OOP是为了代码重用	627
本章小结	629
本章习题	629
习题解答	630
第26章 类代码编写基础	631
类产生多个实例对象	631
类对象提供默认行为	632
实例对象是具体的元素	632
第一个例子	632
类通过继承进行定制	635
第二个例子	635
类是模块内的属性	637
类可以截获Python运算符	638
第三个例子	639
为什么要使用运算符重载	641
世界上最简单的Python类	641
类与字典的关系	644
本章小结	646
本章习题	646
习题解答	646
第27章 更多实例	649
步骤1：创建实例	650
编写构造函数	650
在进行中测试	651
以两种方式使用代码	652
版本差异提示	654
步骤2：添加行为方法	654
编写方法	656
步骤3：运算符重载	658
提供打印显示	658
步骤4：通过子类定制行为	659
编写子类	660
扩展方法：不好的方式	660
扩展方法：好的方式	661
多态的作用	663
继承、定制和扩展	664
OOP：大思路	664
步骤5：定制构造函数	665
OOP比我们认为的要简单	666
组合类的其他方式	667
在Python 3.0中捕获内置属性	669
步骤6：使用内省工具	670
特殊类属性	670
一种通用显示工具	671
实例与类属性的关系	672
工具类的命名考虑	673
类的最终形式	674
步骤7（最后一步）：把对象存储到数据库中	676
Pickle和Shelve	676
在shelve数据库中存储对象	677
交互地探索shelve	678
更新shelve中的对象	680
未来方向	681
本章小结	683
本章习题	684
习题解答	684
第28章 类代码编写细节	686
class语句	686
一般形式	686
例子	687
方法	689
例子	690
调用超类构造函数	691
其他方法调用的可能性	691
继承	692
属性树的构造	692
继承方法的专有化	693
类接口技术	694
抽象超类	695
Python 2.6和Python 3.0的抽象超类	696
命名空间：完整的内容	698
简单变量名：如果赋值就不是全局变量	698
属性名称：对象命名空间	698
Python命名空间的“禅”：赋值将变量名分类	699
命名空间字典	701
命名空间链接	704
回顾文档字符串	706
类与模块的关系	707
本章小结	708
本章习题	708
习题解答	708
第29章 运算符重载	710
基础知识	710
构造函数和表达式：__init__和__sub__	711
常见的运算符重载方法	711
索引和分片：__getitem__和__setitem__	713
拦截分片	713
Python 2.6中的分片和索引	715
索引迭代：__getitem__	716
迭代器对象：__iter__和__next__	717
用户定义的迭代器	717
有多个迭代器的对象	719
成员关系：__contains__、__iter__和__getitem__	721
属性引用：__getattr__和__setattr__	723
其他属性管理工具	725
模拟实例属性的私有性：第一部分	725
__repr__和__str__会返回字符串表达形式	726
右侧加法和原处加法：__radd__和__iadd__	729
原处加法	730
Call表达式：__call__	731
函数接口和回调代码	732
比较：__lt__、__gt__和其他方法	734
Python 2.6的__cmp__方法（已经从Python 3.0中移除了）	734
布尔测试：__bool__和__len__	735
Python 2.6中的布尔	736
对象析构函数：__del__	738
本章小结	739
本章习题	739
习题解答	739
第30章 类的设计	741
Python和OOP	741
通过调用标记进行重载（或不要）	742
OOP和继承：“是一个”关系	743
OOP和组合：“有一个”关系	744
重访流处理器	746
为什么要在意：类和持续性	748
OOP和委托：“包装”对象	749
类的伪私有属性	751
变量名压缩概览	751
为什么使用伪私有属性	752
方法是对象：绑定或无绑定	754
在Python 3.0中，无绑定方法是函数	756
绑定方法和其他可调用对象	757
为什么要在意：绑定方法和回调函数	760
多重继承：“混合”类	760
编写混合显示类	761
类是对象：通用对象的工厂	771
为什么有工厂	772
与设计相关的其他话题	773
本章小结	773
本章习题	774
习题解答	774
第31章 类的高级主题	775
扩展内置类型	775
通过嵌入扩展类型	776
通过子类扩展类型	777
新式类	779
新式类变化	780
类型模式变化	781
钻石继承变动	785
新式类的扩展	789
slots实例	789
类特性	793
__getattribute__和描述符	795
元类	795
静态方法和类方法	796
为什么使用特殊方法	796
Python 2.6和Python 3.0中的静态方法	797
静态方法替代方案	799
使用静态和类方法	800
使用静态方法统计实例	801
用类方法统计实例	802
装饰器和元类：第一部分	805
函数装饰器基础	805
装饰器例子	806
类装饰器和元类	807
更多详细信息	808
类陷阱	809
修改类属性的副作用	809
修改可变的类属性也可能产生副作用	810
多重继承：顺序很重要	811
类、方法以及嵌套作用域	812
Python中基于委托的类：__getattr__和内置函数	814
“过度包装”	814
本章小结	815
本章习题	815
习题解答	815
第六部分练习题	816
为什么要在意：大师眼中的OOP	821
第七部分 异常和工具
第32章 异常基础	825
为什么使用异常	826
异常的角色	826
异常处理：简明扼要	827
默认异常处理器	827
捕获异常	828
引发异常	829
用户定义的异常	830
终止行为	830
为什么要在意：错误检查	832
本章小结	833
本章习题	833
习题解答	834
第33章 异常编码细节	835
try/except/else语句	835
try语句分句	836
try/else分句	839
例子：默认行为	840
例子：捕捉内置异常	841
try/finally语句	841
例子：利用try/finally编写终止行为	842
统一try/except/finally语句	843
统一try语句语法	845
通过嵌套合并finally和except	845
合并try的例子	846
raise语句	847
利用raise传递异常	849
Python 3.0异常链：raise from	849
assert语句	850
例子：收集约束条件（但不是错误）	850
with/as环境管理器	851
基本使用	852
环境管理协议	853
本章小结	855
本章习题	855
习题解答	856
第34章 异常对象	857
异常：回到未来	858
字符串异常很简单	858
基于类的异常	858
类异常例子	859
为什么使用类异常	861
内置Exception类	864
内置异常分类	865
默认打印和状态	866
定制打印显示	867
定制数据和行为	868
提供异常细节	868
提供异常方法	869
本章小结	870
本章习题	870
习题解答	870
第35章 异常的设计	872
嵌套异常处理器	872
例子：控制流程嵌套	873
例子：语法嵌套化	874
异常的习惯用法	876
异常不总是错误	876
函数信号条件和raise	876
关闭文件和服务器连接	877
在try外进行调试	878
运行进程中的测试	879
关于sys.exc_info	879
与异常有关的技巧	880
应该包装什么	881
捕捉太多：避免空except语句	881
捕捉过少：使用基于类的分类	883
核心语言总结	884
Python工具集	884
大型项目的开发工具	885
本章小结	888
第七部分练习题	889
第八部分 高级话题注1
第36章 Unicode和字节字符串	893
Python 3.0中的字符串修改	894
字符串基础知识	895
字符编码方法	895
Python的字符串类型	897
文本和二进制文件	899
Python 3.0中的字符串应用	900
常量和基本属性	900
转换	901
编码Unicode字符串	903
编码ASCII文本	903
编码非ASCII文本	904
编码和解码非ASCII文本	904
其他Unicode编码技术	905
转换编码	907
在Python 2.6中编码Unicode字符串	908
源文件字符集编码声明	910
使用Python 3.0 Bytes对象	911
方法调用	912
序列操作	913
创建bytes对象的其他方式	913
混合字符串类型	914
使用Python 3.0（和Python 2.6）bytearray对象	915
使用文本文件和二进制文件	918
文本文件基础	919
Python 3.0中的文本和二进制模式	919
类型和内容错误匹配	921
使用Unicode文件	922
在Python 3.0中读取和写入Unicode	922
在Python 3.0中处理BOM	924
Python 2.6中的Unicode文件	927
Python 3.0中其他字符串工具的变化	927
re模式匹配模块	927
Struct二进制数据模块	928
pickle对象序列化模块	931
XML解析工具	932
本章小结	935
本章习题	935
习题解答	936
第37章 管理属性	938
为什么管理属性	938
插入在属性访问时运行的代码	939
特性	940
基础知识	940
第一个例子	941
计算的属性	942
使用装饰器编写特性	943
描述符	944
基础知识	945
第一个示例	947
计算的属性	949
在描述符中使用状态信息	950
特性和描述符是如何相关的	952
__getattr__和__getattribute__	953
基础知识	954
第一个示例	956
计算属性	958
__getattr__和__getattribute__比较	959
管理技术比较	960
拦截内置操作属性	963
重访基于委托的Manager	967
示例：属性验证	970
使用特性来验证	971
使用描述符验证	973
使用__getattr__来验证	974
使用__getattribute__验证	976
本章小结	977
本章习题	977
习题解答	977
第38章 装饰器	979
什么是装饰器	979
管理调用和实例	980
管理函数和类	980
使用和定义装饰器	981
为什么使用装饰器	981
基础知识	982
函数装饰器	982
类装饰器	986
装饰器嵌套	988
装饰器参数	990
装饰器管理函数和类	991
编写函数装饰器	991
跟踪调用	992
状态信息保持选项	993
类错误之一：装饰类方法	997
计时调用	1002
添加装饰器参数	1004
编写类装饰器	1007
单体类	1007
跟踪对象接口	1009
类错误之二：保持多个实例	1012
装饰器与管理器函数的关系	1013
为什么使用装饰器（重访）	1015
直接管理函数和类	1016
示例：“私有”和“公有”属性	1018
实现私有属性	1019
实现细节之一	1021
公有声明的泛化	1022
实现细节之二	1024
开放问题	1025
Python不是关于控制	1029
示例：验证函数参数	1030
目标	1030
针对位置参数的一个基本范围测试装饰器	1031
针对关键字和默认泛化	1033
实现细节	1036
开放问题	1038
装饰器参数 VS 函数注解	1039
其他应用程序：类型测试	1041
本章小结	1042
本章习题	1042
习题解答	1043
第39章 元类	1046
要么是元类，要么不是元类	1046
提高魔力层次	1047
“辅助”函数的缺点	1049
元类与类装饰器的关系：第一回合	1051
元类模型	1053
类是类型的实例	1053
元类是Type的子类	1055
Class语句协议	1056
声明元类	1057
编写元类	1058
基本元类	1058
定制构建和初始化	1059
其他元类编程技巧	1060
实例与继承的关系	1063
示例：向类添加方法	1064
手动扩展	1064
基于元类的扩展	1065
元类与类装饰器的关系：第二回合	1067
示例：对方法应用装饰器	1070
用装饰器手动跟踪	1070
用元类和装饰器跟踪	1071
把任何装饰器应用于方法	1073
元类与类装饰器的关系：第三回合	1074
“可选的”语言功能	1076
本章小结	1078
本章习题	1078
习题解答	1078
第九部分 附录注2
附录A 安装和配置	1083
附录B 各部分练习题的解答 1093

## 下载 ##

+ [百度云下载](http://pan.baidu.com/s/1bedMQ)
+ [微盘下载](http://vdisk.weibo.com/s/aADaW4YREXF2Q)
+ [MEGA下载](https://mega.co.nz/#!HUkASTbY!EBkghzI4ANBNFZQgywkI_LYzC9wIoquCnMt0Ncgxizk)
+ [千易下载](http://1000eb.com/1ggbr)

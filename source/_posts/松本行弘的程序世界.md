title: 松本行弘的程序世界
date: 2015-04-29 13:39:01
categories:
  - ruby
---

![](http://img5.douban.com/lpic/s11290956.jpg)

格式：EPUB
类型：文字版

<!--more-->

## 出版信息 ##

作者: 松本行弘 
出版社: 人民邮电出版社
原作名: まつもとゆきひろ コードの世界~スーパー・プログラマになる14の思考法
译者: 柳德燕 / 李黎明 / 夏倩 / 张文旭 
出版年: 2011-8
页数: 389
定价: 75.00元
丛书: 图灵程序设计丛书
ISBN: 9787115255075

## 简介 ##

《松本行弘的程序世界》是探索程序设计思想和方法的经典之作。作者从全局的角度，利用大量的程序示例及图表，深刻阐述了Ruby编程语言的设计理念，并以独特的视角考察了与编程相关的各种技术。阅读《松本行弘的程序世界》不仅可以深入了解编程领域各个要素之间的关系，而且能够学到大师的思考方法。
《松本行弘的程序世界》面向各层次程序设计人员和编程爱好者，也可以供相关技术人员参考。

## 目录 ##

第1 章 我为什么开发Ruby　　1
1.1 我为什么开发Ruby 　　 2
1.1.1 编程语言的重要性　　2
1.1.2 Ruby 的原则　　 3
1.1.3 简洁性　　 4
1.1.4 扩展性　　 5
1.1.5 稳定性　　 6
1.1.6 一切皆因兴趣　　 7
第2 章 面向对象　　 9
2.1 编程和面向对象的关系　　 10
2.1.1 颠倒的构造　　10
2.1.2 主宰计算机的武器　　11
2.1.3 怎样写程序　　 12
2.1.4 面向对象的编程方法　　12
2.1.5 面向对象的难点　　13
2.1.6 多态性　　13
2.1.7 具体的程序　　14
2.1.8 多态性的优点　　15
2.2 数据抽象和继承　　16
2.2.1 面向对象的历史　　16
2.2.2 复杂性是面向对象的敌人　　18
2.2.3 结构化编程　　18
2.2.4 数据抽象化　　19
2.2.5 雏形　　21
2.2.6 找出相似的部分来继承　　 22
2.3 多重继承的缺点　　23
2.3.1 为什么需要多重继承　　23
2.3.2 多重继承和单一继承不可分离　　 24
2.3.3 goto 语句和多重继承比较相似　　 25
2.3.4 解决多重继承的问题　　25
2.3.5 静态语言和动态语言的区别　　 26
2.3.6 静态语言的特点　　26
2.3.7 动态语言的特点　　 27
2.3.8 静态语言和动态语言的比较　　 27
2.3.9 继承的两种含义　　 28
2.3.10 接口的缺点　　28
2.3.11 继承实现的方法　　 29
2.3.12 从多重继承变形而来的Mix-in　　 29
2.3.13 积极支持Mix-in 的Ruby 　　30
2.4 两个误解　　 31
2.4.1 面向对象的编程　　31
2.4.2 对象的模板 = 类　　33
2.4.3 利用模块的手段＝继承　　 33
2.4.4 多重继承不好吗　　34
2.4.5 动态编程语言也需要多重继承　　35
2.4.6 驯服多重继承的方法　　35
2.4.7 Ruby 中多重继承的实现方法　　 37
2.4.8 Java 实现多重继承的方法　　 38
2.5 Duck Typing 诞生之前　　39
2.5.1 为什么需要类型　　39
2.5.2 动态的类型是从Lisp 中诞生的　　 40
2.5.3 动态类型在面向对象中发展起来了　　41
2.5.4 动态类型和静态类型的邂逅　　 42
2.5.5 静态类型的优点　　 42
2.5.6 动态类型的优点　　 43
2.5.7 只关心行为的Duck Typing 　　 44
2.5.8 避免明确的类型检查　　　 45
2.5.9 克服动态类型的缺点　　　46
2.5.10 动态编程语言　　 46
2.6 元编程　　 46
2.6.1 元编程　　　 46
2.6.2 反射　　 47
2.6.3 元编程的例子　　 48
2.6.4 使用反射功能　　 48
2.6.5 分布式Ruby 的实现　　　49
2.6.6 数据库的应用　　　50
2.6.7 输出XML 　　51
2.6.8 元编程和小编程语言　　51
2.6.9 声明的实现　　52
2.6.10 上下文相关的实现　　52
2.6.11 单位的实现　　53
2.6.12 词汇的实现　　53
2.6.13 层次数据的实现　　54
2.6.14 适合DSL 的语言，不适合DSL 的语言　　54
第3 章 程序块　　57
3.1 程序块的威力　　58
3.1.1 把函数作为参数的高阶函数　　58
3.1.2 C 语言高阶函数的局限　　59
3.1.3 可以保存外部环境的闭包　　60
3.1.4 块的两种使用方法　　60
3.1.5 最终来看，块到底是什么　　61
3.1.6 块在循环处理中的应用　　62
3.1.7 内部迭代器和外部迭代器　　62
3.1.8 在排序和比较大小中的应用　　63
3.1.9 用块保证程序的后处理　　63
3.1.10 用块实现新的控制结构　　64
3.1.11 在回调中使用块　　　65
3.1.12 块处理的特别理由　　　65
3.2 用块作循环　　66
3.2. 1 块是处理的集合　　67
3.2.2 块应用范围的扩展　　68
3.2.3 高阶函数和块的本质一样　　69
3.2.4 用Enumerable 来利用块　　69
3.2.5 Enumerable 的局限　　74
3.3 精通集合的使用　　77
3.3.1 使用Ruby 的数组　　77
3.3.2 修改指定范围的元素内容　　78
3.3.3 Ruby 中的哈希处理　　78
3.3.4 支持循环的Enumerable　　79
3.3.5 用于循环的each 方法　　81
3.3.6 使用inject、zip 和grep　　81
3.3.7 用来指定条件的select 方法　　 82
3.3.8 排序与比较大小的方法　　 83
3.3.9 在类中包含（include）Enumerable 模块　　 84
3.3.10 List 的内部包和块的区别　　 85
第4 章 设计模式　　　 89
4.1 设计模式（1）　　 90
4.1.1 设计模式的价值和意义　　 91
4.1.2 设计模式是程序抽象化的延伸　　 92
4.1.3 Ruby 中的设计模式　　92
4.1.4 Singleton 模式　　 92
4.1.5 Proxy 模式　　94
4.1.6 Iterator 模式　　95
4.1.7 外部与内部，哪一个更好　　 96
4.1.8 内部迭代器的缺陷　　 97
4.1.9 外部迭代器的缺陷　　 98
4.2 设计模式（2）　　98
4.2.1 模式与动态语言的关系　　 99
4.2.2 重复使用既存对象的Prototype模式　　 99
4.2.3 亲身体验Io 语言　　100
4.2.4 Ruby 中的原型　　 101
4.2.5 编写抽象算法的Template Method模式　　101
4.2.6 用Ruby 来尝试TemplateMethod　　　102
4.2.7 动态语言与Template Method模式　　104
4.2.8 避免高度依赖性的Observer模式　　104
4.2.9 Observable 模块　　105
4.2.10 Observer 模式与动态语言　　 107
4.3 设计模式（3）　　 107
4.3.1 软件开发的悲剧　　 108
4.3.2 开放— 封闭原则　　 108
4.3.3 面向对象的情况　　109
4.3.4 非面向对象的情况　　110
4.3.5 OCP 与Template Method 模式　　 111
4.3.6 Observer 模式　　 113
4.3.7 使用Strategy 模式　　 114
4.3.8 Strategy 模式与OCP　　 116
第5 章 Ajax 　　119
5.1 Ajax 和JavaScript（前篇）　　120
5.1.1 通信及异步页面更新　　120
5.1.2 技术要素之一：JavaScript 　　 122
5.1.3 技术要素之二：XML　　122
5.1.4 XML 以外的数据表现形式　　 123
5.1.5 技术要素之三：DHTML　　 124
5.1.6 JavaScript 技术基础　　124
5.1.7 原型模式的面向对象编程语言　　 126
5.1.8 使用prototype.js 库　　127
5.1.9 prototype.js 的功能　　 127
5.2 Ajax 和JavaScript（后篇）　　 130
5.2.1 巧妙使用DHTML　　 131
5.2.2 获取document 节点　　132
5.2.3 获取和更新标签数据　　133
5.2.4 设定事件处理程序　　133
5.2.5 追加标签节点　　135
5.2.6 本地HTML 应用　　135
5.2.7 和服务器间的通信　　　137
5.2.8 使用Prototype.js 的优点　　 138
5.2.9 在服务器上保存数据　　 138
5.2.10 Web 应用的脆弱性　　140
5.2.11 使用JavaScript 的感觉　　 141
第6 章 Ruby on Rails 　　 143
6.1 MVC 和Ruby on Rails 　　 144
6.1.1 模型、视图和控制的作用　　144
6.1.2 用秒表的例子来学习MVC模式　　　145
6.1.3 生成视图和控制部分　　 147
6.1.4 GUI 工具箱与MVC　　148
6.1.5 同时使用工具箱和MVC　　 149
6.1.6 MVC 的优缺点　　 151
6.1.7 Web 应用中的MVC 　　 152
6.2 开放类和猴子补丁　　 153
6.2.1 开放类　　154
6.2.2 猴子补丁的目的　　154
6.2.3 猴子补丁的技巧　　 155
6.2.4 灵活使用开放类的库　　159
6.2.5 猴子补丁的几点问题　　161
6.2.6 其他办法　　 162
6.2.7 Ruby on Rails 和开放类　 165
6.2.8 ActiveSupport 带来的扩展　　166
6.2.9 字节单位系列　　　168
6.2.10 复数形和序数　　 168
6.2.11 大规模开发和Ruby 　　169
6.2.12 信赖性模型　　　170
6.2.13 猴子补丁的未来　　170
第7 章 文字编码　　173
7.1 文字编码的种类　　174
7.1.1 早期的文字编码　　174
7.1.2 纸带与文字表现　　175
7.1.3 文字是什么　　 176
7.1.4 走向英语以外的语言（欧洲篇）　　 177
7.1.5 英语以外的语言（亚洲篇） 　　177
7.1.6 Unicode 的问世　　180
7.1.7 统一编码成16 位的汉字统合　　 181
7.1.8 Unicode 的两个问题　　181
7.1.9 Unicode 的文字集　　182
7.1.10 文字表示的不确定性　　183
7.1.11 Unicode 的字符编码方式　　 183
7.2 程序中的文字处理　　 185
7.2.1 文字编码有多个意思　　185
7.2.2 只能处理文字集中包含的文字　　 185
7.2.3 纷繁复杂的文字编码方式　　 186
7.2.4 影响力渐微的Shift_JIS 与EUC-JP　　186
7.2.5 Unicode 有多种字符编码方式　　 186
7.2.6 为什么会发生乱码　　 188
7.2.7 字符编码方式错误　　188
7.2.8 没有字体　　189
7.2.9 变换为内部码时出错　　189
7.2.10 发生不完全变换　　189
7.2.11 文字集的不同　　190
7.2.12 字节顺序错误　　191
7.2.13 从编程语言的角度处理文字　　191
7.2.14 以变换为前提的UCS 方式　　191
7.2.15 原封不动处理的CSI 方式　　192
7.2.16 使用UTF-16 的Java　　192
7.2.17 使用UTF-8 的Perl 　　193
7.2.18 用UTF-16 的Python 　　194
7.2.19 采用CSI 方式的Ruby 1.8　　194
7.2.20 强化了功能的Ruby 1.9　　195
7.2.21 是UCS 还是CSI　　196
第8 章 正则表达式　　　199
8.1 正则表达式基础　　　200
8.1.1 检索“像那样的东西”　　200
8.1.2 正则表达式的语法　　200
8.1.3 3 个陷阱　　203
8.1.4 正则表达式对象　　204
8.1.5 选项　　205
8.1.6 正则表达式匹配的方法　　206
8.1.7 特殊变量　　207
8.1.8 字符串与正则表达式　　207
8.1.9 split 的本质　　207
8.1.10 字符串的扫描　　208
8.1.11 置换　　208
8.2 正则表达式的应用实例与“鬼车” 　　210
8.2.1 解析日志文件的方法　　211
8.2.2 避免使用$的方法　　213
8.2.3 从邮件中取出日期的方法　　215
8.2.4 典型拼写错误的检索方法　　216
8.2.5 Ruby 1.9 的新功能“鬼车” 　　216
第9 章 整数和浮点小数　　219
9.1 深奥的整数世界　　220
9.1.1 整数是有范围的　　　221
9.1.2 尝试位运算　　222
9.1.3 操作特定的位　　223
9.1.4 表示负数的办法　　225
9.1.5 Ruby 的整数　　226
9.1.6 挑战公开密钥方式　　227
9.2 扑朔迷离的浮点小数世界　　228
9.2.1 计算机对小数的处理　　229
9.2.2 固定小数点数不易使用　　229
9.2.3 科学计数法也有问题　　 229
9.2.4 小数不能完全表示　　 230
9.2.5 有不能比较的时候　　231
9.2.6 误差积累　　 232
9.2.7 不是数的特别“数” 　　232
9.2.8 计算误差有多种　　 233
9.2.9 误差导致的严重问题　　 235
9.2.10 BigDecimal 是什么　　 236
9.2.11 能够表示分数的Rational类　　 236
第10 章 高速执行和并行处理　　 239
10.1 让程序高速执行（前篇）　　240
10.1.1 是不是越快越好　　 240
10.1.2 高速执行的乐趣与效率　　240
10.1.3 以数据为基础作出判断　　241
10.1.4 改善系统调用　　 241
10.1.5 数据可靠吗　　 243
10.1.6 只需改善瓶颈　　 243
10.1.7 profiler 本身成了累赘　　 245
10.1.8 算法与数据结构　　 245
10.1.9 理解O 记法　　245
10.1.10 选择算法　　 246
10.1.11 调查算法的性能　　 246
10.1.12 高速执行的悲哀　　 247
10.1.13 性能优化的格言　　 248
10.2 让程序高速执行（后篇）　　 248
10.2.1 确认程序概要　　　　 249
10.2.2 发现瓶颈　　 250
10.2.3 使用更好的profiler　　 251
10.2.4 高速优化之一：削减对象　　 252
10.2.5 高速优化之二：利用立即值　　 254
10.2.6 高速优化之三：利用C 语言　　 255
10.2.7 高速优化之四：采用合适的数据结构　　256
10.2.8 全部以C 语言计算　　 257
10.2.9 还存在其他技巧　　257
10.3 并行编程　　258
10.3.1 使用线程的理由　　 258
10.3.2 生成线程　　 259
10.3.3 线程的执行状态　　260
10.3.4 传递值给线程的方法　　261
10.3.5 信息共有所产生的问题　　262
10.3.6 数据完整性的丧失　　 262
10.3.7 死锁　　 263
10.3.8 用锁来实现对资源的独占　　264
10.3.9 二级互斥　　 265
10.3.10 用队列协调线程　　265
10.3.11 锁模型与队列模型的比较　　 267
10.4 前景可期的并行编程技术，Actor 　　 268
10.4.1 何谓Actor　　268
10.4.2 操作Actor 的3 种处理系统　　 269
10.4.3 Erlang 的程序　　 270
10.4.4 Pingpong 处理的开始　　 270
10.4.5 启动pingpong 程序　　 271
10.4.6 Erlang 的错误处理　　　272
10.4.7 Erlang 的使用场所　　　273
10.4.8 面向Ruby 的库“Revactor”　　 273
10.4.9 Revactor 的应用场合　　274
10.4.10 另一个库Dramatis 　　275
第11 章 程序安全性　　　 279
11.1 程序的漏洞与攻击方法　　280
11.1.1 4 种软件漏洞　　 280
11.1.2 因权限被窃取而成为重大问题　　 281
11.1.3 安全问题的根源　　281
11.1.4 “守护神”引起的问题　　 282
11.1.5 多 样化的攻击手段　　 282
11.1.6 缓冲区溢出　　 283
11.1.7 整数溢出　　284
11.1.8 SQL 注入　　285
11.1.9 Shell 注入　　286
11.1.10 跨站点脚本攻击　　 287
11.1.11 跨站点伪造请求　　 288
11.1.12 社会工程　　　　 289
11.2 用异常进行错误处理　　 290
11.2.1 异常的历史　　 292
11.2.2 Java 的受控异常　　292
11.2.3 Icon 的面向目标判断　　 293
11.2.4 Ruby 的异常　　294
11.2.5 异常发生　　295
11.2.6 异常类　　 296
11.2.7 异常处理的设计方针　　297
11.2.8 异常发生的设计原则　　 298
第12 章 关于时间的处理　　301
12.1 用程序处理时刻与时间　　 302
12.1.1 时差与时区　　302
12.1.2 世界协调时间　　302
12.1.3 夏令时（DST）　　 303
12.1.4 改历　　304
12.1.5 日期与时间的类　　 305
12.1.6 2038 年问题　　308
12.1.7 DateTime 类　　309
12.1.8 Time 与DateTime 的相互变换　　310
第13 章 关于数据的持久化　　313
13.1 持久化数据的方法　　314
13.1.1 保存文本　　 314
13.1.2 变换成文本的Marshal 　　 314
13.1.3 使用Marshal 模块　　315
13.1.4 复制有两种方式　　 316
13.1.5 仔细看Marshal 的格式　　 316
13.1.6 不能保存的3 类对象　　317
13.1.7 制作面向对象数据库　　318
13.1.8 试用PStore 　　 318
13.1.9 变换为文本的YAML 　　 320
13.1.10 用YAML 制作数据库　　 321
13.2 对象的保存　　　322
13.2.1 高速的Object Prevalence 　　 322
13.2.2 Object Prevalence 的问题点　　 323
13.2.3 使用Madeleine 　　323
13.2.4 访问时刻信息　　325
13.2.5 让Madeleine 更容易使用　　326
13.2.6 Madeleine 的实用例Instiki 　　 328
13.3 关于XML 的考察　　328
13.3.1 XML 的祖先是SGML 　　 329
13.3.2 XML 是树结构的数据表现　　329
13.3.3 优点在于纯文本　　330
13.3.4 缺点在于冗长　　331
13.3.5 不适合重视效率的处理　　331
13.3.6 适合于信息交换的格式　　332
13.3.7 XML 的解析　　332
13.3.8 XML 处理库REXML　　333
13.3.9 XML 的代替　　336
第14 章 函数式编程　　339
14.1 新范型——函数式编程　　340
14.1.1 具有多种函数式性质的Lisp　　341
14.1.2 彻底的函数式编程语言Haskell 　　342
14.1.3 延迟计算：不必要的处理就不做　　343
14.1.4 灵活的“静态多态性”类型系统　　344
14.1.5 近代函数式语言之父OCaml 　　345
14.1.6 强于并行计算的Erlang　　345
14.1.7 用Ruby 进行函数式编程　　346
14.1.8 用枚举器来实现延迟计算　　347
14.2 自动生成代码　　348
14.2.1 在商业中利用Ruby　　349
14.2.2 使用Ruby 自动生成代码　　350
14.2.3 消除重复代码　　350
14.2.4 代码生成的应用　　351
14.2.5 代码生成的效果　　352
14.2.6 编写代码生成器　　353
14.2.7 也可以使用XML　　354
14.2.8 在EJB 中使用代码生成　　355
14.3 内 存管理与垃圾收集　　　356
14.3.1 内存管理的困难　　357
14.3.2 垃圾收集亮相之前　　358
14.3.3 评价垃圾收集的两个指标　　359
14.3.4 垃圾收集算法　　360
14.3.5 引用计数方式　　360
14.3.6 标记和扫除方式　　361
14.3.7 标记和紧缩方式　　362
14.3.8 复制方式　　 363
14.3.9 多种多样的垃圾收集算法　　 364
14.3.10 分代垃圾收集　　 364
14.3.11 保守垃圾收集　　366
14.3.12 增量垃圾收集　　366
14.3.13 并行垃圾收集　　367
14.3.14 位图标记　　 367
14.4 用C 语言来扩展Ruby　　368
14.4.1 开发与执行速度的取舍　　368
14.4.2 扩展库　　369
14.4.3 看例题学习扩展模块　　370
14.4.4 QDBM 函数　　372
14.4.5 初始化对象　　373
14.4.6 实现方法　　374
14.4.7 关于垃圾收集的注意事项　　376
14.4.8 其他的Ruby API　　376
14.4.9 扩展库的编译　　 376
14.4.10 扩展库以外的工具　　 377
14.5 为什么要开源　　 380
14.5.1 自由软件的思想　　380
14.5.2 自由软件的历史　　 381
14.5.3 Emacs 事件的发生　　 381
14.5.4 开源的诞生　 382
14.5.5 OSS 许可证　　383
14.5.6 开源的背景　　385
14.5.7 企业关注开源的理由　　 386
14.5.8 Ruby 与开源　　386
14.5.9 选择许可证的方法　　387

## 下载 ##

* [微盘下载](http://vdisk.weibo.com/s/aADaW4YROA17p)
* [百度云下载](http://pan.baidu.com/s/1hqw4yYo)
* [MEGA下载](https://mega.co.nz/#!PI02jZYK!-XibxanYTvEGEG6eRKienGwt9Vid2WU0iu26b1FV1UQ)
* [千易下载](http://1000eb.com/1ggi9)

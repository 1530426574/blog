title: 现代编译原理 c语言描述 （中文版）
date: 2015-05-21 00:14:15
categories:
  - 编译
---

![](http://img4.douban.com/lpic/s1852496.jpg)

格式：PDF
类型：扫描版
大小：14.2M

<!--more-->

## 出版信息 ##

作者: (美)安佩尔 
出版社: 人民邮电出版社
副标题: C语言描述
原作名: Modern Compiler Implementation in C
译者: 赵克佳 / 黄春 / 沈志宇 
出版年: 2006-4
页数: 385
定价: 45.00元
装帧: 简裝本
ISBN: 9787115145529

## 简介 ##

《现代编译原理:C语言描述》全面讲述了现代编译器的结构、编译算法和实现方法，是Andrew w．Apple的“虎书”——Modern Compiler Implementation——“红、蓝、绿”三序列之一。这三本书的内容基本相同。但是使用不同的语言来实现书中给出的一个编译器。本书使用的是更适合广大读者的c语言，而另外两本书分别采用ML语言和Java语言。本书的另一个特点是增加了一些其他编译原理教科书没有涉及的内容。前端增加了面向对象的程序设计语言、函数式程序设计语言等现代语言的编译实现方法，后端增加了针对现代计算机体系结构特征的一些比较成熟的优化方法。这部分内容展现了现代商业编译器需解决的一些关键问题，开拓了学生的视野，为学生未来进行更深入的研究奠定了基础。
《现代编译原理:C语言描述》全面讲述了现代编译器的各个组成部分，包括词法分析、语法分析、抽象语法、语义检查、中间代码表示、指令选择、数据流分析、寄存器分配以及运行时系统等。全书分成两部分，第一部分是编译的基础知识，适用于第一门编译原理课程(一个学期)；第二部分是高级主题，包括面向对象语言和函数语言、垃圾收集、循环优化、ssA(静态单赋值)形式、循环调度、存储结构优化等，适合于后续课程或研究生教学。书中专门为学生提供了一个用C语言编写的实习项目，包括前端和后端设计，学生可以在一学期内创建一个功能完整的编译器。

## 目录 ##

第一部分 编译基本原理
第1章 绪论
1.1 模块与接口
1.2 工具和软件
1.3 树语言的数据结构
程序设计：直线式程序解释器
推荐阅读
习题
第2章 词法分析
2.1 词法单词
2.2 正则表达式
2.3 有限自动机
2.4 非确定有限自动机
2.4.1 将正则表达式转换为NFA
2.4.2 将NFA转换为DFA
2.5 Lex：词法分析器的生成器
程序设计：词法分析
推荐阅读
习题
第3章 语法分析
3.1 上下文无关文法
3.1.1 推导
3.1.2 语法分析树
3.1.3 二义性文法
3.1.4 文件结束符
3.2 预测分析
3.2.1 FIRST集合和FOLLOW集合
3.2.2 构造一个预测分析器
3.2.3 消除左递归
3.2.4 提取左因子
3.2.5 错误恢复
3.3 LR分析
3.3.1 LR分析引擎
3.3.2 LR(0)分析器生成器
3.3.3 SLR分析器的生成
3.3.4 LR(1)项和LR(1)分析表
3.3.5 LALR(1)分析表
3.3.6 各类文法的层次
3.3.7 二义性文法的LR分析
3.4 使用分析器的生成器
3.4.1 冲突
3.4.2 优先级指导
3.4.3 语法和语义
3.5 错误恢复
3.5.1 用error符号恢复
3.5.2 全局错误修复
程序设计：语法分析
推荐阅读
习题
第4章 抽象语法
4.1 语义动作
4.1.1 递归下降
4.1.2 Yacc生成的分析器
4.1.3 语义动作的解释器
4.2 抽象语法分析树
4.2.1 位置
4.2.2 Tiger的抽象语法
程序设计：抽象语法
推荐阅读
习题
第5章 语义分析
5.1 符号表
5.1.1 多个符号表
5.1.2 高效的命令式风格符号表
5.1.3 高效的函数式符号表
5.1.4 Tiger编译器的符号
5.1.5 函数式风格的符号表
5.2 Tiger编译器的绑定
5.3 表达式的类型检查
5.4 声明的类型检查
5.4.1 变量声明
5.4.2 类型声明
5.4.3 函数声明
5.4.4 递归声明
程序设计：类型检查
习题
第6章 活动记录
6.1 栈帧
6.1.1 帧指针
6.1.2 寄存器
6.1.3 参数传递
6.1.4 返回地址
6.1.5 栈帧内的变量
6.1.6 静态链
6.2 Tiger编译器的栈帧
6.2.1 栈帧描述的表示
6.2.2 局部变量
6.2.3 计算逃逸变量
6.2.4 临时变量和标号
6.2.5 两层抽象
6.2.6 管理静态链
6.2.7 追踪层次信息
程序设计：栈帧
推荐阅读
习题
第7章 翻译成中间代码
7.1 中间表示树
7.2 翻译为树中间语言
7.2.1 表达式的种类
7.2.2 简单变量
7.2.3 追随静态链
7.2.4 数组变量
7.2.5 结构化的左值
7.2.6 下标和域选择
7.2.7 关于安全性的劝告
7.2.8 算术操作
7.2.9 条件表达式
7.2.10 字符串
7.2.11 记录和数组的创建
7.2.12 while循环
7.2.13 for循环
7.2.14 函数调用
7.3 声明
7.3.1 变量定义
7.3.2 函数定义
7.3.3 片段
程序设计：翻译成树
习题
第8章 基本块和轨迹
8.1 规范树
8.1.1 ESEQ的转换
8.1.2 一般重写规则
8.1.3 将CALL移到顶层
8.1.4 线性语句表
8.2 处理条件分支
8.2.1 基本块
8.2.2 轨迹
8.2.3 完善
8.2.4 最优轨迹
推荐阅读
习题
第9章 指令选择
9.1 指令选择算法
9.1.1 Maximal Munch算法
9.1.2 动态规划
9.1.3 树文法
9.1.4 快速匹配
9.1.5 覆盖算法的效率
9.2 CISC机器
9.3 Tiger编译器的指令选择
9.3.1 抽象的汇编语言指令
9.3.2 生成汇编指令
9.3.3 过程调用
9.3.4 无帧指针的情形
程序设计：指令选择
推荐阅读
习题
第10章 活跃分析
10.1 数据流方程的解
10.1.1 活跃性计算
10.1.2 集合的表示
10.1.3 时间复杂度
10.1.4 最小不动点
10.1.5 静态活跃性与动态活跃性
10.1.6 冲突图
10.2 Tiger编译器的活跃分析
10.2.1 图
10.2.2 控制流图
10.2.3 活跃分析
程序设计：构造流图
程序设计：活跃分析模块
习题
第11章 寄存器分配
11.1 通过简化进行着色
11.2 合并
11.3 预着色的结点
11.3.1 机器寄存器的临时副本
11.3.2 调用者保护的寄存器和被调用者保护的寄存器
11.3.3 含预着色结点的例子
11.4 图着色的实现
11.4.1 传送指令工作表的管理
11.4.2 数据结构
11.4.3 程序代码
11.5 针对树的寄存器分配
程序设计：图着色
推荐阅读
习题
第12章 整合为一体
程序设计：过程入口/出口
程序设计：创建一个可运行的编译器
第二部分 高级主题
第13章 垃圾收集
13.1 标记-清扫式收集
13.2 引用计数
13.3 复制式收集
13.4 分代收集
13.5 增量式收集
13.6 Baker算法
13.7 编译器接口
13.7.1 快速分配
13.7.2 数据布局的描述
13.7.3 导出指针
程序设计：描述字
程序设计：垃圾收集
推荐阅读
习题
第14章 面向对象的语言
14.1 类
14.2 数据域的单继承性
14.3 多继承性
14.4 测试类成员关系
14.5 私有域和私有方法
14.6 无类语言
14.7 向对象程序的优化
程序设计：OBJECT Tiger
推荐阅读
习题
第15章 函数式程序设计语言
15.1 一个简单的函数式语言
15.2 闭包
15.3 不变的变量
15.3.1 基于延续的……I/O226
15.3.2 语言上的变化
15.3.3 纯函数式语言的优化
15.4 内联扩展
15.5 闭包变换
15.6 高效的尾递归
15.7 懒惰计算
15.7.1 传名调用计算
15.7.2 按需调用
15.7.3 懒惰程序的计算
15.7.4 懒惰函数式程序的优化
15.7.5 严格性分析
推荐阅读
程序设计：编译函数式语言
习题
第16章 多态类型
16.1 参数多态性
16.1.1 显式带类型的多态语言
16.1.2 多态类型的检查
16.2 类型推论
16.2.1 一个隐式类型的多态语言
16.2.2 类型推论算法
16.2.3 递归的数据类型
16.2.4 Hindley Milner类型的能力
16.3 多态变量的表示
16.3.1 多态函数的扩展
16.3.2 完全的装箱转换
16.3.3 基于强制的表示分析
16.3.4 将类型作为运行时参数传递
16.4 静态重载的解决方法
推荐阅读
习题
第17章 数据流分析
17.1 流分析使用的中间表示
17.2 各种数据流分析
17.2.1 到达定值
17.2.2 可用表达式
17.2.3 到达表达式
17.2.4 活跃分析
17.3 使用数据流分析结果的几种转换
17.3.1 公共子表达式删除
17.3.2 常数传播
17.3.3 复写传播
17.3.4 死代码删除
17.4 加快数据流分析
17.4.1 位向量
17.4.2 基本块
17.4.3 结点排序
17.4.4 使用-定值链和定值-使用链
17.4.5 工作表算法
17.4.6 增量式数据流分析
17.5 别名分析
17.5.1 基于类型的别名分析
17.5.2 基于流的别名分析
17.5.3 使用可能别名信息
17.5.4 严格的纯函数式语言中的别名分析
推荐阅读
习题
第18章 循环优化
18.1 必经结点
18.1.1 寻找必经结点的算法
18.1.2 直接必经结点
18.1.3 循环
18.1.4 循环前置结点
18.2 循环不变量计算
18.3 归纳变量
18.3.1 发现归纳变量
18.3.2 强度削弱
18.3.3 删除
18.3.4 重写比较
18.4 数组边界检查
18.5 循环展开
推荐阅读
习题
第19章 静态单赋值形式
19.1 转化为SSA形式
19.1.1 插入Φ函数的标准
19.1.2 必经结点边界
19.1.3 插入Φ函数
19.1.4 变量重命名
19.1.5 边分割
19.2 必经结点树的高效计算
19.2.1 深度优先生成树
19.2.2 半必经结点
19.2.3 Lengauer Tarjan算法
19.3 使用SSA的优化算法
19.3.1 死代码删除
19.3.2 简单的常数传播
19.3.3 条件常数传播
19.3.4 保持必经结点性质
19.4 数组、指针和存储器
19.5 控制依赖图
19.6 从SSA形式转变回来
19.7 函数式中间形式
推荐阅读
习题
第20章 流水和调度
20.1 没有资源约束时的循环调度
20.2 有资源约束的循环流水
20.2.1 模调度
20.2.2 寻找最小的启动间距
20.2.3 其他控制流
20.2.4 编译器应该调度指令吗
20.3 分支预测
20.3.1 静态分支预测
20.3.2 编译器应该预测分支吗
推荐阅读
习题
第21章 存储层次
21.1 cache的组织结构
21.2 cache块对齐
21.3 预取
21.4 循环交换
21.5 分块
21.6 垃圾收集和存储层次
推荐阅读
习题
附录 Tiger语言参考手册
参考文献
索引

## 下载 ##

+ [微盘下载](http://vdisk.weibo.com/s/aADaW4YREXCon)
+ [MEGA下载](https://mega.co.nz/#!uNVURCaY!ugNtCOdD6ECwScBJTwjwPUNn7JGU0ZWCOrAltARXZBM)
title: 操作系统：精髓与设计原理 （中文第六版）
date: 2015-04-29 14:00:05
categories:
  - os
---

![](http://img5.douban.com/lpic/s4450637.jpg)

格式：PDF
类型：扫描版
大小：11.8M

<!--more-->

## 出版信息 ##

作者: William Stallings 
出版社: 机械工业出版社
副标题: 精髓与设计原理（原书第6版）
原作名: Operating Systems: Internals and Design Principles, Sixth Edition
译者: 陈向群 / 陈渝 
出版年: 2010.9
页数: 572
定价: 69.00元
装帧: 平装
丛书: 计算机科学丛书
ISBN: 9787111304265

## 简介 ##

本书不仅全面地讲述了操作系统的基本概念、原理和方法，还清楚地展现了当代操作系统的本质和特点。作者针对近几年操作系统领域的最新变化，对操作系统的设计原理进行深入的阐述，同时将其对操作系统整个领域全面而深入的理解呈现给读者。

## 目录 ##

出版者的话
译者序
前言
第0章 读者指南	1
0.1 本书概述	1
0.2 读者和教师的学习路线图	1
0.3 Internet和Web资源	2
第一部分 背景
第1章 计算机系统概述	6
1.1 基本构成	6
1.2 处理器寄存器	6
1.2.1 用户可见寄存器	7
1.2.2 控制和状态寄存器	8
1.3 指令的执行	9
1.3.1 取指令和执行指令	9
1.3.2 I/O函数	11
1.4 中断	11
1.4.1 中断和指令周期	12
1.4.2 中断处理	14
1.4.3 多个中断	15
1.4.4 多道程序设计	17
1.5 存储器的层次结构	17
1.6 高速缓存	20
1.6.1 动机	20
1.6.2 高速缓存原理	20
1.6.3 高速缓存设计	21
1.7 I/O通信技术	22
1.7.1 可编程I/O	22
1.7.2 中断驱动I/O	22
1.7.3 直接内存存取	24
1.8 推荐读物和网站	24
1.9 关键术语、复习题和习题	25
附录1A 两级存储器的性能特征	27
附录1B 过程控制	30
第2章 操作系统概述	33
2.1 操作系统的目标和功能	33
2.1.1 作为用户/计算机接口的
2.1.1 操作系统	33
2.1.2 作为资源管理器的操作
2.1.1 系统	34
2.1.3 操作系统的易扩展性	35
2.2 操作系统的发展	35
2.2.1 串行处理	35
2.2.2 简单批处理系统	36
2.2.3 多道程序设计批处理系统	38
2.2.4 分时系统	40
2.3 主要的成就	42
2.3.1 进程	42
2.3.2 内存管理	44
2.3.3 信息保护和安全	46
2.3.4 调度和资源管理	46
2.3.5 系统结构	47
2.4 现代操作系统的特征	49
2.5 微软的Windows 概述	51
2.5.1 历史	51
2.5.2 单用户多任务	53
2.5.3 体系结构	53
2.5.4 客户/服务器模型	56
2.5.5 线程和SMP	57
2.5.6 Windows对象	57
2.6 传统的UNIX系统	58
2.6.1 历史	58
2.6.2 描述	59
2.7 现代UNIX系统	60
2.7.1 系统V版本4（SVR4）	60
2.7.2 BSD	61
2.7.3 Solaris 10	61
2.8 Linux操作系统	61
2.8.1 历史	62
2.8.2 模块结构	63
2.8.3 内核组件	64
2.9 推荐读物和网站	67
2.10 关键术语、复习题和习题	68
第二部分 进程
第3章 进程描述和控制	73
3.1 什么是进程	73
3.1.1 背景	73
3.1.2 进程和进程控制块	74
3.2 进程状态	75
3.2.1 两状态进程模型	76
3.2.2 进程的创建和终止	77
3.2.3 五状态模型	78
3.2.4 被挂起的进程	81
3.3 进程描述	84
3.3.1 操作系统的控制结构	85
3.3.2 进程控制结构	86
3.4 进程控制	90
3.4.1 执行模式	90
3.4.2 进程创建	91
3.4.3 进程切换	92
3.5 操作系统的执行	93
3.5.1 无进程的内核	94
3.5.2 在用户进程中执行	94
3.5.3 基于进程的操作系统	95
3.6 安全问题	95
3.6.1 系统访问威胁	96
3.6.2 对抗措施	96
3.7 UNIX SVR4进程管理	98
3.7.1 进程状态	98
3.7.2 进程描述	99
3.7.3 进程控制	101
3.8 小结	102
3.9 推荐读物	102
3.10 关键术语、复习题和习题	102
编程项目1：开发一个shell程序	105
第4章 线程、对称多处理（SMP）
第4章 和微内核	107
4.1 进程和线程	107
4.1.1 多线程	107
4.1.2 线程功能特性	109
4.1.3 例子：Adobe PageMaker	111
4.1.4 用户级和内核级线程	112
4.1.5 其他方案	115
4.2 对称多处理	116
4.2.1 SMP体系结构	116
4.2.2 SMP系统的组织结构	117
4.2.3 多处理器操作系统的
4.2.3 设计思考	118
4.3 微内核	119
4.3.1 微内核体系结构	119
4.3.2 微内核组织结构的优点	120
4.3.3 微内核性能	121
4.3.4 微内核设计	121
4.4 Windows线程和SMP管理	122
4.4.1 进程对象和线程对象	123
4.4.2 多线程	125
4.4.3 线程状态	125
4.4.4 对操作系统子系统的支持	126
4.4.5 对称多处理的支持	126
4.5 Solaris的线程和SMP管理	127
4.5.1 多线程体系结构	127
4.5.2 动机	127
4.5.3 进程结构	128
4.5.4 线程的执行	129
4.5.5 把中断当做线程	129
4.6 Linux的进程和线程管理	130
4.6.1 Linux任务	130
4.6.2 Linux线程	131
4.7 小结	132
4.8 推荐读物	133
4.9 关键术语、复习题和习题	133
第5章 并发性：互斥和同步	138
5.1 并发的原理	139
5.1.1 一个简单的例子	139
5.1.2 竞争条件	141
5.1.3 操作系统关注的问题	141
5.1.4 进程的交互	141
5.1.5 互斥的要求	144
5.2 互斥：硬件的支持	144
5.2.1 中断禁用	144
5.2.2 专用机器指令	145
5.3 信号量	147
5.3.1 互斥	150
5.3.2 生产者/消费者问题	151
5.3.3 信号量的实现	154
5.4 管程	155
5.4.1 使用信号的管程	155
5.4.2 使用通知和广播的管程	158
5.5 消息传递	159
5.5.1 同步	160
5.5.2 寻址	161
5.5.3 消息格式	162
5.5.4 排队原则	162
5.5.5 互斥	162
5.6 读者-写者问题	163
5.6.1 读者优先	164
5.6.2 写者优先	164
5.7 小结	166
5.8 推荐读物	167
5.9 关键术语、复习题和习题	167
第6章 并发：死锁和饥饿	178
6.1 死锁的原理	178
6.1.1 可重用资源	180
6.1.2 可消耗资源	181
6.1.3 资源分配图	182
6.1.4 死锁的条件	183
6.2 死锁预防	184
6.2.1 互斥	184
6.2.2 占有且等待	184
6.2.3 不可抢占	184
6.2.4 循环等待	184
6.3 死锁避免	185
6.3.1 进程启动拒绝	185
6.3.2 资源分配拒绝	186
6.4 死锁检测	189
6.4.1 死锁检测算法	189
6.4.2 恢复	190
6.5 一种综合的死锁策略	190
6.6 哲学家就餐问题	191
6.6.1 使用信号量解决方案	191
6.6.2 使用管程解决方案	192
6.7 UNIX的并发机制	192
6.7.1 管道	192
6.7.2 消息	193
6.7.3 共享内存	193
6.7.4 信号量	194
6.7.5 信号	194
6.8 Linux内核并发机制	195
6.8.1 原子操作	195
6.8.2 自旋锁	196
6.8.3 信号量	197
6.8.4 屏障	199
6.9 Solaris线程同步原语	199
6.9.1 互斥锁	200
6.9.2 信号量	200
6.9.3 多读者/单写者锁	201
6.9.4 条件变量	201
6.10 Windows并发机制	201
6.10.1 等待函数	201
6.10.2 分派器对象	202
6.10.3 临界区	203
6.10.4 轻量级读写锁和条件变量	203
6.11 小结	204
6.12 推荐读物	204
6.13 关键术语、复习题和习题	205
第三部分 内存
第7章 内存管理	210
7.1 内存管理的需求	210
7.1.1 重定位	210
7.1.2 保护	211
7.1.3 共享	211
7.1.4 逻辑组织	211
7.1.5 物理组织	211
7.2 内存分区	212
7.2.1 固定分区	212
7.2.2 动态分区	214
7.2.3 伙伴系统	216
7.2.4 重定位	218
7.3 分页	219
7.4 分段	222
7.5 安全问题	222
7.5.1 缓冲区溢出攻击	222
7.5.2 预防缓冲区溢出	225
7.6 小结	225
7.7 推荐读物	225
7.8 关键术语、复习题和习题	225
附录7A 加载和链接	228
第8章 虚拟内存	232
8.1 硬件和控制结构	232
8.1.1 局部性和虚拟内存	233
8.1.2 分页	235
8.1.3 分段	242
8.1.4 段页式	243
8.1.5 保护和共享	244
8.2 操作系统软件	244
8.2.1 读取策略	245
8.2.2 放置策略	246
8.2.3 置换策略	246
8.2.4 驻留集管理	251
8.2.5 清除策略	255
8.2.6 加载控制	255
8.3 UNIX和Solaris内存管理	257
8.3.1 分页系统	257
8.3.2 内核内存分配器	259
8.4 Linux内存管理	260
8.4.1 Linux虚拟内存	260
8.4.2 内核内存分配	261
8.5 Windows内存管理	262
8.5.1 Windows虚拟地址映射	263
8.5.2 Windows分页	263
8.6 小结	264
8.7 推荐读物和网站	264
8.8 关键术语、复习题和习题	265
附录8A 散列表	268
第四部分 调度
第9章 单处理器调度	272
9.1 处理器调度的类型	272
9.1.1 长程调度	273
9.1.2 中程调度	274
9.1.3 短程调度	274
9.2 调度算法	274
9.2.1 短程调度准则	274
9.2.2 优先级的使用	275
9.2.3 选择调度策略	276
9.2.4 性能比较	284
9.2.5 公平共享调度	287
9.3 传统的UNIX调度	289
9.4 小结	290
9.5 推荐读物	291
9.6 关键术语、复习题和习题	291
附录9A 响应时间	294
附录9B 排队系统	296
编程项目2：主机调度shell程序	299
第10章 多处理器和实时调度	304
10.1 多处理器调度	304
10.1.1 粒度	304
10.1.2 设计问题	307
10.1.3 进程调度	308
10.1.4 线程调度	309
10.2 实时调度	312
10.2.1 背景	312
10.2.2 实时操作系统的特点	313
10.2.3 实时调度	315
10.2.4 限期调度	316
10.2.5 速率单调调度	319
10.2.6 优先级反转	321
10.3 Linux调度	322
10.3.1 实时调度	322
10.3.2 非实时调度	323
10.4 UNIX SVR4调度	325
10.5 Windows调度	326
10.5.1 进程和线程优先级	326
10.5.2 多处理器调度	328
10.6 小结	328
10.7 推荐读物	328
10.8 关键术语、复习题和习题	329
第五部分 I/O和文件
第11章 I/O管理和磁盘调度	334
11.1 I/O设备	334
11.2 I/O功能的组织	335
11.2.1 I/O功能的发展	335
11.2.2 直接存储器访问	336
11.3 操作系统设计问题	337
11.3.1 设计目标	337
11.3.2 I/O功能的逻辑结构	338
11.4 I/O缓冲	339
11.4.1 单缓冲	340
11.4.2 双缓冲	341
11.4.3 循环缓冲	341
11.4.4 缓冲的作用	341
11.5 磁盘调度	342
11.5.1 磁盘性能参数	342
11.5.2 磁盘调度策略	344
11.6 RAID	347
11.6.1 RAID级别0	349
11.6.2 RAID级别1	350
11.6.3 RAID级别2	351
11.6.4 RAID级别3	351
11.6.5 RAID级别4	352
11.6.6 RAID级别5	353
11.6.7 RAID级别6	353
11.7 磁盘高速缓存	353
11.7.1 设计考虑	353
11.7.2 性能考虑	355
11.8 UNIX SVR4 I/O	355
11.8.1 缓冲区高速缓存	356
11.8.2 字符队列	356
11.8.3 无缓冲I/O	357
11.8.4 UNIX设备	357
11.9 Linux I/O	357
11.9.1 磁盘调度	358
11.9.2 Linux页面缓存	360
11.10 Windows I/O	360
11.10.1 基本I/O机制	360
11.10.2 异步I/O和同步I/O	361
11.10.3 软件RAID	361
11.10.4 卷影复制	361
11.10.5 卷加密	362
11.11 小结	362
11.12 推荐读物	362
11.13 关键术语、复习题和习题	363
附录11A 磁盘存储设备	365
第12章 文件管理	371
12.1 概述	371
12.1.1 文件和文件系统	371
12.1.2 文件结构	371
12.1.3 文件管理系统	373
12.2 文件组织和访问	375
12.2.1 堆	376
12.2.2 顺序文件	376
12.2.3 索引顺序文件	377
12.2.4 索引文件	377
12.2.5 直接文件或散列文件	378
12.3 文件目录	378
12.3.1 内容	378
12.3.2 结构	379
12.3.3 命名	380
12.4 文件共享	381
12.4.1 访问权限	381
12.4.2 同时访问	381
12.5 记录组块	382
12.6 二级存储管理	383
12.6.1 文件分配	383
12.6.2 空闲空间的管理	387
12.6.3 卷	388
12.6.4 可靠性	388
12.7 文件系统安全	389
12.8 UNIX文件管理	390
12.8.1 索引节点	391
12.8.2 文件分配	392
12.8.3 目录	393
12.8.4 卷结构	393
12.8.5 传统的UNIX文件访问
6.10.4 控制	393
12.8.6 UNIX中的访问控制列表	394
12.9 Linux虚拟文件系统	395
12.9.1 超级块对象	397
12.9.2 索引节点对象	397
12.9.3 目录项对象	398
12.9.4 文件对象	398
12.10 Windows文件系统	398
12.10.1 NTFS的重要特征	398
12.10.2 NTFS卷和文件结构	399
12.10.3 可恢复性	401
12.11 小结	402
12.12 推荐读物	402
12.13 关键术语、复习题和习题	403
第六部分 嵌入式系统
第13章 嵌入式操作系统	406
13.1 嵌入式系统	406
13.2 嵌入式操作系统的特点	407
13.2.1 移植现有的商业操作系统	408
13.2.2 为特定目的构建的嵌入式
6.10.4 操作系统	408
13.3 eCos	409
13.3.1 可配置性	409
13.3.2 eCos组件	411
13.3.3 eCos调度程序	414
13.3.4 eCos线程同步	415
13.4 TinyOS	419
13.4.1 无线传感器网络	420
13.4.2 TinyOS的目标	420
13.4.3 TinyOS的组件	421
13.4.4 TinyOS的调度程序	423
13.4.5 配置例子	423
13.4.6 TinyOS的资源接口	425
13.5 推荐读物和网站	426
13.6 关键术语、复习题和习题	426
第七部分 安全
第14章 计算机安全威胁	430
14.1 计算机安全的概念	430
14.2 威胁、攻击和资产	431
14.2.1 威胁和攻击	431
14.2.2 威胁和资产	432
14.3 入侵者	434
14.3.1 入侵者行为模式	435
14.3.2 入侵技术	437
14.4 恶意软件概述	437
14.4.1 后门	437
14.4.2 逻辑炸弹	438
14.4.3 特洛伊木马	438
14.4.4 移动代码	438
14.4.5 多威胁恶意软件	439
14.5 病毒、蠕虫与僵尸	440
14.5.1 病毒	440
14.5.2 蠕虫	443
14.5.3 僵尸	445
14.6 rootkits	447
14.6.1 rootkit安装	447
14.6.2 系统级调用攻击	447
14.7 推荐读物和网站	448
14.8 关键术语、复习题和习题	448
第15章 计算机安全技术	451
15.1 身份验证	451
15.1.1 身份验证方法	451
15.1.2 基于密码的身份验证	451
15.1.3 基于令牌的身份验证	453
15.1.4 生物特征识别认证	454
15.2 访问控制	455
15.2.1 自主访问控制	456
15.2.2 基于角色的访问控制	458
15.3 入侵检测	460
15.3.1 基本原则	460
15.3.2 基于主机的入侵检测技术	461
15.3.3 审计记录	462
15.4 恶意软件防御	463
15.4.1 反病毒方法	463
15.4.2 蠕虫对策	465
15.4.3 自动代理程序的对策	466
15.4.4 rootkit对策	466
15.5 处理缓冲区溢出攻击	467
15.5.1 编译时防御	467
15.5.2 运行时防御	469
15.6 Windows Vista安全性	470
15.6.1 访问控制方案	470
15.6.2 访问令牌	471
15.6.3 安全描述符	471
15.7 推荐读物和网站	474
15.8 关键术语、复习题和习题	475
第八部分 分布式系统
第16章 分布式处理、客户/服务器和
第16章 集群	481
16.1 客户/服务器计算模型	481
16.1.1 什么是客户/服务器
16.1.1 计算模型	481
16.1.2 客户/服务器模型的应用	482
16.1.3 中间件	486
16.2 分布式消息传递	487
16.2.1 可靠性与不可靠性	488
16.2.2 阻塞与无阻塞	488
16.3 远程过程调用	489
16.3.1 参数传递	490
16.3.2 参数表示	490
16.3.3 客户/服务器绑定	490
16.3.4 同步和异步	490
16.3.5 面向对象机制	491
16.4 集群	491
16.4.1 集群的配置	491
16.4.2 操作系统的设计问题	493
16.4.3 集群计算机的体系结构	494
16.4.4 集群与SMP的比较	495
16.5 Windows集群服务器	495
16.6 Sun集群	496
16.6.1 对象和通信支持	497
16.6.2 进程管理	497
16.6.3 网络连接	497
16.6.4 全局文件系统	498
16.7 Beowulf和Linux集群	498
16.7.1 Beowulf特征	498
16.7.2 Beowulf软件	499
16.8 小结	500
16.9 推荐读物和网站	500
16.10 关键术语、复习题和习题	501
附录A 并发主题	503
附录B 面向对象设计	516
附录C 编程和操作系统项目	523
术语表	528
参考文献	536

## 下载 ##

* [微盘下载](http://vdisk.weibo.com/s/aADaW4YROsmRY)
* [百度云下载](http://pan.baidu.com/s/1ntLw3Df)
* [MEGA下载](https://mega.co.nz/#!jR0FEbhL!WS9edQfs3cHGPM178eSg_hcEvFO37W9prUvnT-KK3x0)
title: 自制编程语言 （中文版）
date: 2015-04-29 15:50:55
categories:
  - 编译
---

![](http://img3.douban.com/lpic/s27093931.jpg)

格式：EPUB
类型：文字版

<!--more-->

## 出版信息 ##

作者: ［日］ 前桥和弥 
出版社: 人民邮电出版社
译者: 刘卓 / 徐谦 / 吴雅明 
出版年: 2013-11
页数: 396
定价: 79.00
装帧: 平装
ISBN: 9787115333209

## 简介 ##

本书手把手地教读者用C语言制作两种编程语言：crowbar与Diksam。crowbar是运行分析树的无类型语言，Diksam是运行字节码的静态类型语言。这两种语言都具备四则运算、变量、条件分支、循环、函数定义、垃圾回收等功能，最终版则可以支持面向对象、异常处理等高级机制。所有源代码都提供下载，读者可以一边对照书中的说明一边调试源代码。这个过程对理解程序的运行机制十分有帮助。
本书适合有一定基础的程序员和编程语言爱好者阅读。

## 目录 ##

第1章 　引子　　001
1.1 为什么要制作编程语言　　002
1.2 自制编程语言并不是很难　　003
1.3 本书的构成与面向读者　　004
1.4 用什么语言来制作　　006
1.5 要制作怎样的语言　　007
1.5.1 要设计怎样的语法　　007
1.5.2 要设计怎样的运行方式　　009
补充知识 　“用户”指的是谁？　　012
补充知识 　解释器并不会进行翻译　　012
1.6 环境搭建　　012
1.6.1 搭建开发环境　　012
补充知识 关于bison与flex的安装　　014
1.6.2 本书涉及的源代码以及编译器　　015
第2章 　试做一个计算器　　017
2.1 yacc/lex是什么　　018
补充知识 　词法分析器与解析器是各自独立的　　019
2.2 试做一个计算器　　020
2.2.1 lex　　021
2.2.2 简单正则表达式讲座　　024
2.2.3 yacc　　026
2.2.4 生成执行文件　　033
2.2.5 理解冲突所代表的含义　　034
2.2.6 错误处理　　040
2.3 不借助工具编写计算器　　041
2.3.1 自制词法分析器　　041
补充知识 　保留字（关键字）　　046
补充知识 避免重复包含　　047
2.3.2 自制语法分析器　　048
补充知识 预读记号的处理　　053
2.4 少许理论知识——LL(1)与LALR(1)　　054
补充知识 Pascal/C 中的语法处理诀窍　　056
2.5 习题：扩展计算器　　056
2.5.1 让计算器支持括号　　056
2.5.2 让计算器支持负数　　058
第3章 　制作无类型语言crowbar　　061
3.1　制作crowbar ver.0.1语言的基础部分　　062
3.1.1 crowbar是什么　　062
3.1.2 程序的结构　　063
3.1.3 数据类型　　064
3.1.4 变量　　064
补充知识 初次赋值兼做变量声明的理由　　066
补充说明 各种语言的全局变量处理　　067
3.1.5 语句与结构控制　　067
补充知识 elif、elsif、elseif的选择　　068
3.1.6 语句与运算符　　069
3.1.7 内置函数　　069
3.1.8 让crowbar支持C 语言调用　　070
3.1.9 从crowbar中调用C 语言（内置函数的编写）　　071
3.2 预先准备　　071
3.2.1 模块与命名规则　　072
3.2.2 内存管理模块MEM　　073
补充知识 valgrind　　075
补充知识 富翁式编程　　075
补充知识 符号表与扣留操作　　076
3.2.3 调试模块DBG　　076
3.3 crowbar ver.0.1的实现　　077
3.3.1 crowbar的解释器——CRB_Interpreter　　077
补充知识 不完全类型　　080
3.3.2 词法分析——crowbar.l　　081
补充知识 静态变量的许可范围　　084
3.3.3 分析树的构建——crowbar.y 与create.c　　085
3.3.4 常量折叠　　089
3.3.5 错误信息　　089
补充知识 关于crowbar中使用的枚举型定义　　091
3.3.6 运行——execute.c　　092
3.3.7 表达式评估——eval.c　　096
3.3.8 值——CRB_Value　　104
3.3.9 原生指针型　　105
3.3.10 变量　　106
3.3.11 字符串与垃圾回收机制——string_pool.c　　108
3.3.12 编译与运行　　110
第4章 　数组和mark-sweep垃圾回收器　　113
4.1 crowbar ver.0.2　　114
4.1.1 crowbar的数组　　114
4.1.2 访问数组元素　　115
4.1.3 数组是一种引用类型　　116
补充知识 　“数组的数组”和多维数组　　116
4.1.4 为数组添加元素　　118
4.1.5 增加( 模拟) 函数调用功能　　118
4.1.6 其他细节　　118
4.2 制作mark-sweep GC　　119
4.2.1 引用数据类型的结构　　119
4.2.2　mark-sweep GC　　121
补充知识 引用和immutable　　123
4.2.3 crowbar栈　　124
4.2.4 其他根　　127
4.2.5 原生函数的形式参数　　128
4.3 实现GC 本身　　129
4.3.1 对象的管理方法　　129
4.3.2 GC 何时启动　　129
4.3.3 sweep阶段　　132
补充知识 GC 现存的问题　　133
补充知识 Coping GC　　134
4.4 其他修改　　136
4.4.1 修改语法　　136
4.4.2 函数的模拟　　137
4.4.3 左值的处理　　139
4.4.4 创建数组和原生函数的书写方法　　142
4.4.5 原生指针类型的修改　　144
第5章 　中文支持和Unicode　　147
5.1 中文支持策略和基础知识　　148
5.1.1 现存问题　　148
5.1.2 宽字符（双字节）串和多字节字符串　　149
补充知识 wchar_t 肯定能表示1 个字符吗？　　150
5.1.3 多字节字符/ 宽字符之间的转换函数群　　150
5.2 Unicode　　153
5.2.1 Unicode的历史　　153
5.2.2 Unicode的编码方式　　154
补充知识 Unicode可以固定（字节）长度吗？　　156
5.3 crowbar book_ver.0.3的实现　　156
5.3.1 要实现到什么程度？　　156
5.3.2 发起转换的时机　　157
5.3.3 关于区域设置　　158
5.3.4 解决0x5C问题　　158
补充知识 失败的 #ifdef　　160
5.3.5 应该是什么样子　　160
补充知识 还可以是别的样子——Code Set Independent　　161
第6章 　制作静态类型的语言Diksam　　163
6.1 制作Diksam Ver 0.1语言的基本部分　　164
6.1.1 Diksam的运行状态　　164
6.1.2 什么是Diksam　　165
6.1.3 程序结构　　165
6.1.4 数据类型　　166
6.1.5 变量　　166
6.1.6 语句和流程控制　　167
6.1.7 表达式　　167
6.1.8 内建函数　　168
6.1.9 其他　　168
6.2 什么是静态的/ 执行字节码的语言　　169
6.2.1 静态类型的语言　　169
6.2.2 什么是字节码　　169
6.2.3 将表达式转换为字节码　　170
6.2.4 将控制结构转换为字节码　　173
6.2.5 函数的实现　　173
6.3 Diksam ver.0.1的实现——编译篇　　175
6.3.1 目录结构　　175
6.3.2 编译的概要　　176
6.3.3 构建分析树（create.c）　　176
6.3.4 修正分析树（fix_tree.c）　　179
6.3.5 Diksam的运行形式——DVM_Executable　　185
6.3.6 常量池　　186
补充知识 YARV 的情况　　187
6.3.7 全局变量　　188
6.3.8 函数　　189
6.3.9 顶层结构的字节码　　189
6.3.10 行号对应表　　190
6.3.11 栈的需要量　　190
6.3.12 生成字节码（generate.c）　　191
6.3.13 生成实际的编码　　193
6.4 Diksam虚拟机　　197
6.4.1 加载/ 链接DVM_Executable到DVM　　200
6.4.2 执行——巨大的switch case　　202
6.4.3 函数调用　　204
第7章 　为Diksam引入数组　　207
7.1 Diksam中数组的设计　　208
7.1.1 声明数组类型的变量　　208
7.1.2 数组常量　　209
补充知识 D 语言的数组　　210
7.2 修改编译器　　210
7.2.1 数组的语法规则　　210
7.2.2 TypeSpecifier结构体　　212
7.3 修改DVM　　213
7.3.1 增加指令　　213
补充知识 创建Java 的数组常量　　215
补充知识 C 语言中数组的初始化　　217
7.3.2 对象　　217
补充知识 ArrayStoreException　　218
7.3.3 增加null　　219
7.3.4 哎! 还缺点什么吧？　　219
第8章 　将类引入Diksam　　221
8.1 分割源文件　　222
8.1.1 包和分割源代码　　222
补充知识 #include、文件名、行号　　225
8.1.2 DVM_ExecutableList　　225
8.1.3 ExecutableEntry　　226
8.1.4 分开编译源代码　　227
8.1.5 加载和再链接　　230
补充知识 动态加载时的编译器　　233
8.2 设计Diksam中的类　　233
8.2.1 超简单的面向对象入门　　233
8.2.2 类的定义和实例创建　　237
8.2.3 继承　　239
8.2.4 关于接口　　241
8.2.5 编译与接口　　242
8.2.6 Diksam怎么会设计成这样？　　243
8.2.7 数组和字符串的方法　　245
8.2.8 检查类的类型　　246
8.2.9 向下转型　　246
8.3 关于类的实现——继承和多态　　247
8.3.1 字段的内存布局　　247
8.3.2 多态——以单继承为前提　　249
8.3.3 多继承——C++　　250
8.3.4 Diksam的多继承　　252
补充知识 无类型语言中的继承　　254
8.3.5 重写的条件　　254
8.4 关于类的实现　　256
8.4.1 语法规则　　256
8.4.2 编译时的数据结构　　258
8.4.3 DVM_Executable中的数据结构　　260
8.4.4 与类有关的指令　　262
补充知识 方法调用、括号和方法指针　　263
8.4.5 方法调用　　264
8.4.6 super　　266
8.4.7 类的链接　　266
8.4.8 实现数组和字符串的方法　　267
8.4.9 类型检查和向下转型　　267
补充知识 对象终结器（finalizer）和析构函数（destructor）　　268
第9章 　应用篇　　271
9.1 为crowbar引入对象和闭包　　272
9.1.1 crowbar的对象　　272
9.1.2 对象实现　　273
9.1.3 闭包　　274
9.1.4 方法　　276
9.1.5 闭包的实现　　278
9.1.6 试着跟踪程序实际执行时的轨迹　　281
9.1.7 闭包的语法规则　　284
9.1.8 普通函数　　284
9.1.9 模拟方法（修改版）　　285
9.1.10 基于原型的面向对象　　286
9.2 异常处理机制　　286
9.2.1 为crowbar引入异常　　286
9.2.2 setjmp()/longjmp()　　289
补充知识 Java 和C# 异常处理的不同　　293
9.2.3 为Diksam引入异常　　295
补充知识 catch 的编写方法　　296
9.2.4 异常的数据结构　　297
9.2.5 异常处理时生成的字节码299
9.2.6 受查异常　　301
补充知识 受查异常的是与非 303
补充知识 异常处理本身的是与非　　304
9.3 构建脚本　　305
9.3.1 基本思路　　306
9.3.2 YY_INPUT　　307
9.3.3 Diksam的构建脚本　　308
9.3.4 三次加载/ 链接　　308
9.4 为crowbar引入鬼车　　309
9.4.1 关于“鬼车”　　309
9.4.2 正则表达式常量　　310
9.4.3 正则表达式的相关函数　　311
9.5 其他　　312
9.5.1 foreach 和迭代器（crowbar）　　312
9.5.2 switch case（Diksam)　　314
9.5.3 enum（Diksam）　　315
9.5.4 delegate（Diksam）　　316
9.5.5 final、const（Diksam）　　319
附录A 　crowbar语言的设计　　322
附录B 　Diksam语言的设计　　336
附录C 　Diksam Virtual Machine 指令集　　359
编程语言实用化指南——写在最后　　369
参考文献　　375

## 下载 ##

* [微盘下载](http://vdisk.weibo.com/s/aADaW4YROSj3e)
* [百度云下载](http://pan.baidu.com/s/1eQ7xfJc)
* [MEGA下载](https://mega.co.nz/#!HZlmjJ4J!AojNWWw0PDqRA9ICcfSKnaSV49uWTDwYMsQcmj1Hs0I)
* [千易下载](http://1000eb.com/1ggih)
